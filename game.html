<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Skyline Ace: Precise Controls</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;500;700&display=swap');
        :root { --accent: #00f2ff; --danger: #ff4444; --ally: #00ff88; --glass: rgba(0, 0, 0, 0.7); }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Quicksand', sans-serif; touch-action: none; color: white; }
        
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, rgba(10,30,70,0.95), #000);
            z-index: 2000; transition: opacity 0.8s;
        }
        .card {
            background: var(--glass); backdrop-filter: blur(25px);
            padding: 25px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            text-align: center; width: 80%; max-width: 380px;
        }
        h1 { font-weight: 300; letter-spacing: 6px; margin: 0 0 15px; font-size: 1.8rem; }
        .opt-btn {
            flex: 1; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2);
            color: white; border-radius: 8px; cursor: pointer; font-size: 11px;
        }
        .opt-btn.active { background: var(--accent); border-color: var(--accent); color: #000; font-weight: 700; }
        .start-btn {
            width: 100%; margin-top: 20px; padding: 15px; border-radius: 50px;
            background: #fff; color: #000; border: none; font-weight: 700; cursor: pointer;
        }

        /* HUD & Controls Container */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; display: none; }
        .hud-el { position: absolute; padding: 8px 12px; background: var(--glass); border-radius: 8px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .hud-tl { top: 15px; left: 15px; border-left: 3px solid var(--accent); }
        .hud-tr { top: 15px; right: 15px; text-align: right; border-right: 3px solid var(--danger); }
        .hud-tm { top: 15px; left: 50%; transform: translateX(-50%); text-align: center; width: 100px; }
        
        /* Central Radar - Largest UI element */
        #radar-ui {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 130px; height: 130px; border-radius: 50%; border: 2px solid rgba(0,242,255,0.35);
            background: radial-gradient(circle, rgba(0,30,30,0.6) 0%, rgba(0,10,10,0.8) 100%);
            backdrop-filter: blur(4px); pointer-events: none;
        }
        .radar-dot { position: absolute; width: 4px; height: 4px; border-radius: 50%; transform: translate(-50%, -50%); }
        #radar-player { position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; background: white; border-radius: 50%; transform: translate(-50%, -50%); }

        /* Left Control: Joystick zone with always-visible guide */
        #joystick-zone {
            position: absolute; bottom: 20px; width: 130px; height: 130px;
            pointer-events: auto; z-index: 1000; touch-action: none;
        }
        #joystick-guide {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 80px; height: 80px; border-radius: 50%;
            border: 2px solid rgba(0,242,255,0.3);
            background: radial-gradient(circle, rgba(0,242,255,0.06) 0%, transparent 70%);
            pointer-events: none;
        }
        #joystick-guide::after {
            content: ''; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 24px; height: 24px; border-radius: 50%;
            background: rgba(0,242,255,0.25); border: 1px solid rgba(0,242,255,0.4);
        }

        /* Right Controls: Lever above Fire */
        #speed-lever-zone {
            position: absolute; right: 22px; bottom: 90px;
            height: 120px; width: 50px; pointer-events: auto;
            display: flex; flex-direction: column; align-items: center;
            z-index: 1000; touch-action: none;
        }
        #lever-track {
            width: 8px; height: 100px; background: rgba(255,255,255,0.15);
            border-radius: 4px; position: relative; border: 1px solid rgba(255,255,255,0.2);
        }
        #lever-handle {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 20px; background: var(--accent); border-radius: 4px;
            box-shadow: 0 0 12px var(--accent), 0 0 4px rgba(0,242,255,0.5);
            transition: top 0.2s ease-out;
        }
        #lever-label-up, #lever-label-dn {
            font-size: 7px; opacity: 0.5; letter-spacing: 1px; position: absolute; width: 100%; text-align: center;
        }
        #lever-label-up { top: -14px; }
        #lever-label-dn { bottom: -14px; }

        #fire-btn {
            position: absolute; bottom: 15px; right: 15px; width: 65px; height: 65px;
            border-radius: 10px; background: rgba(255,50,50,0.3); border: 2px solid var(--danger);
            display: flex; justify-content: center; align-items: center; pointer-events: auto;
            color: white; font-weight: 700; z-index: 1000; font-size: 13px;
            box-shadow: 0 0 10px rgba(255,68,68,0.3);
        }

        #msg-box { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); font-size: 18px; color: var(--accent); text-align: center; pointer-events: none; width: 100%; }
    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <div class="card">
            <h1>SKYLINE ACE</h1>
            <div style="text-align:left; margin-bottom:15px;">
                <div style="font-size:9px; opacity:0.6; letter-spacing:2px; margin-bottom:5px;">UNIT</div>
                <div style="display:flex; gap:10px;" id="unit-select">
                    <button class="opt-btn active" data-val="JET">JET</button>
                    <button class="opt-btn" data-val="UFO">UFO</button>
                </div>
            </div>
            <div style="text-align:left; margin-bottom:15px;">
                <div style="font-size:9px; opacity:0.6; letter-spacing:2px; margin-bottom:5px;">ACE LEVEL</div>
                <div style="display:flex; gap:5px;" id="diff-select">
                    <button class="opt-btn active" data-val="1">1</button>
                    <button class="opt-btn" data-val="2">2</button>
                    <button class="opt-btn" data-val="3">3</button>
                    <button class="opt-btn" data-val="4">4</button>
                    <button class="opt-btn" data-val="5">5</button>
                </div>
            </div>
            <div id="level-desc" style="text-align:left; margin-bottom:12px; font-size:10px; opacity:0.7; line-height:1.6; padding:8px; background:rgba(255,255,255,0.03); border-radius:8px; border-left:2px solid var(--accent);">
                Lv1: 10kills, slow, strong auto-aim, HP 8
            </div>
            <div style="text-align:left; margin-bottom:12px;">
                <div style="font-size:9px; opacity:0.6; letter-spacing:2px; margin-bottom:5px;">CONTROLS</div>
                <div style="font-size:9px; opacity:0.5; line-height:1.8;">
                    <span style="color:var(--accent);">LEFT</span> Joystick: Pitch &amp; Roll<br>
                    <span style="color:var(--accent);">RIGHT</span> Lever Up/Down: Accel/Decel<br>
                    <span style="color:var(--danger);">FIRE</span> Button: Shoot (auto-aim)<br>
                    <span style="color:white;">AUTO</span> No input = track nearest enemy<br>
                    <span style="color:white;">P key</span> Pause toggle
                </div>
            </div>
            <button id="start-btn" class="start-btn">INITIATE</button>
        </div>
    </div>

    <div id="over-screen" class="screen" style="display:none;">
        <div class="card">
            <h1 id="over-title" style="font-size:1.5rem;">MISSION END</h1>
            <div id="over-stats" style="margin:15px 0; font-size:14px; opacity:0.8;"></div>
            <button onclick="location.reload()" class="start-btn">REDEPLOY</button>
        </div>
    </div>

    <div id="ui-layer">
        <div class="hud-el hud-tl">
            <div style="font-size:8px; opacity:0.7;">ALT / SPD</div>
            <div style="font-size:16px;"><span id="alt-val">0</span> / <span id="spd-val">0</span></div>
        </div>
        <div class="hud-el hud-tr">
            <div style="font-size:8px; opacity:0.7;">KILLS / GOAL</div>
            <div style="font-size:16px;"><span id="kill-val">0</span> / <span id="target-val">0</span></div>
        </div>
        <div class="hud-el hud-tm">
            <div style="font-size:8px; opacity:0.7;">REMAINING</div>
            <div style="font-size:16px; color:var(--danger);" id="timer-val">60</div>
        </div>
        
        <div id="radar-ui"><div id="radar-player"></div><div id="radar-dots"></div></div>
        
        <div id="speed-lever-zone">
            <div id="lever-track">
                <div id="lever-label-up">ACC</div>
                <div id="lever-handle"></div>
                <div id="lever-label-dn">DEC</div>
            </div>
        </div>
        <div id="joystick-zone"><div id="joystick-guide"></div></div>
        <div id="fire-btn">FIRE</div>
        <div id="msg-box"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        const SOUNDS = {
            engine: 'https://actions.google.com/sounds/v1/transportation/jet_plane_flying_loop.ogg',
            laser: 'https://actions.google.com/sounds/v1/science_fiction/low_laser_shot.ogg',
            explosion: 'https://actions.google.com/sounds/v1/explosions/distant_explosion.ogg'
        };

        class Game {
            constructor() {
                this.state = { active: false, takeoff: false, paused: false, unit: 'JET', difficulty: 1, kills: 0, targetKills: 10, timeLeft: 60 };
                this.input = { joystick: {x:0, y:0}, thrust: 0.5, firing: false };
                this.leverInput = 0;
                this.entities = { player: null, allies: [], enemies: [], bullets: [], ships: [], airliners: [], particles: [], landmarks: [] };
                this.audio = {};
                this.initScene();
                this.setupUI();
                this.clock = new THREE.Clock();
                this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 80000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                document.body.appendChild(this.renderer.domElement);
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            initAudio() {
                const listener = new THREE.AudioListener();
                this.camera.add(listener);
                const loader = new THREE.AudioLoader();
                this.audio.engine = new THREE.Audio(listener);
                loader.load(SOUNDS.engine, buf => { this.audio.engine.setBuffer(buf); this.audio.engine.setLoop(true); this.audio.engine.setVolume(0.2); });
                this.audio.laser = new THREE.Audio(listener);
                loader.load(SOUNDS.laser, buf => { this.audio.laser.setBuffer(buf); this.audio.laser.setVolume(0.3); });
                this.audio.explosion = new THREE.Audio(listener);
                loader.load(SOUNDS.explosion, buf => { this.audio.explosion.setBuffer(buf); this.audio.explosion.setVolume(0.5); });
            }

            initWorld() {
                const isDay = new Date().getHours() > 6 && new Date().getHours() < 19;
                this.scene.background = new THREE.Color(isDay ? 0x66ccff : 0x050520);
                this.scene.fog = new THREE.FogExp2(isDay ? 0x99ccff : 0x0a0a2a, 0.0001);
                this.scene.add(new THREE.AmbientLight(0xffffff, isDay ? 1.0 : 0.6));
                const sun = new THREE.DirectionalLight(0xffffff, 1.3);
                sun.position.set(2000, 3000, -2000);
                this.scene.add(sun);
                const ocean = new THREE.Mesh(new THREE.PlaneGeometry(80000, 80000), new THREE.MeshStandardMaterial({ color: 0x003366, metalness: 0.6, roughness: 0.2 }));
                ocean.rotation.x = -Math.PI/2;
                this.scene.add(ocean);

                this.createLandmarks();
                for(let i=0; i<15; i++) {
                    const ship = this.createShip();
                    ship.position.set((Math.random()-0.5)*40000, 0, (Math.random()-0.5)*40000);
                    this.scene.add(ship);
                    this.entities.ships.push({ mesh: ship, speed: 0.2 + Math.random()*0.3 });
                }
                for(let i=0; i<6; i++) {
                    const plane = this.createAirliner();
                    plane.position.set((Math.random()-0.5)*60000, 3500 + Math.random()*2500, (Math.random()-0.5)*60000);
                    this.scene.add(plane);
                    this.entities.airliners.push({ mesh: plane, speed: 2.5 + Math.random()*1.5, trailTimer: 0 });
                }

                // Clouds
                for(let i=0; i<40; i++) {
                    const cloud = new THREE.Group();
                    const mat = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity: 0.6});
                    for(let j=0; j<4; j++) {
                        const s = new THREE.Mesh(new THREE.SphereGeometry(80 + Math.random()*120, 6, 6), mat);
                        s.position.set((Math.random()-0.5)*200, Math.random()*40, (Math.random()-0.5)*200);
                        cloud.add(s);
                    }
                    cloud.position.set((Math.random()-0.5)*60000, 2000 + Math.random()*3000, (Math.random()-0.5)*60000);
                    this.scene.add(cloud);
                }

                // City buildings (land areas)
                for(let c=0; c<4; c++) {
                    const cx = (Math.random()-0.5)*30000;
                    const cz = (Math.random()-0.5)*30000;
                    for(let i=0; i<20; i++) {
                        const h = 30 + Math.random()*200;
                        const w = 20 + Math.random()*40;
                        const bld = new THREE.Mesh(
                            new THREE.BoxGeometry(w, h, w),
                            new THREE.MeshStandardMaterial({color: 0x334455 + Math.floor(Math.random()*0x222222)})
                        );
                        bld.position.set(cx + (Math.random()-0.5)*600, h/2, cz + (Math.random()-0.5)*600);
                        this.scene.add(bld);
                    }
                }

                // Birds (simple V-shapes flying)
                this.entities.birds = [];
                for(let i=0; i<8; i++) {
                    const bird = new THREE.Group();
                    const wing1 = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), new THREE.MeshBasicMaterial({color:0x222222, side: THREE.DoubleSide}));
                    wing1.rotation.z = 0.3; wing1.position.x = -2;
                    const wing2 = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), new THREE.MeshBasicMaterial({color:0x222222, side: THREE.DoubleSide}));
                    wing2.rotation.z = -0.3; wing2.position.x = 2;
                    bird.add(wing1, wing2);
                    bird.position.set((Math.random()-0.5)*20000, 300 + Math.random()*800, (Math.random()-0.5)*20000);
                    this.scene.add(bird);
                    this.entities.birds.push({ mesh: bird, speed: 0.8 + Math.random()*0.5 });
                }

                this.runway = new THREE.Group();
                const deck = new THREE.Mesh(new THREE.BoxGeometry(300, 15, 2500), new THREE.MeshStandardMaterial({color:0x222222}));
                const strip = new THREE.Mesh(new THREE.PlaneGeometry(15, 2500), new THREE.MeshBasicMaterial({color:0xbbbb00}));
                strip.rotation.x = -Math.PI/2; strip.position.y = 7.6;
                this.runway.add(deck, strip);
                this.scene.add(this.runway);
            }

            createLandmarks() {
                const eiffel = new THREE.Group();
                eiffel.add(new THREE.Mesh(new THREE.BoxGeometry(100, 20, 100), new THREE.MeshStandardMaterial({color:0x555555})));
                const b2 = new THREE.Mesh(new THREE.ConeGeometry(40, 400, 4), new THREE.MeshStandardMaterial({color:0x666666}));
                b2.position.y = 210; eiffel.add(b2);
                eiffel.position.set(5000, 0, -5000);
                this.scene.add(eiffel);
                this.entities.landmarks.push({mesh: eiffel, name: 'EIFFEL'});

                const sol = new THREE.Group();
                sol.add(new THREE.Mesh(new THREE.BoxGeometry(80, 80, 80), new THREE.MeshStandardMaterial({color:0x888888})));
                const body = new THREE.Mesh(new THREE.CylinderGeometry(20, 30, 150, 8), new THREE.MeshStandardMaterial({color:0x66aa99}));
                body.position.y = 115; sol.add(body);
                sol.position.set(-10000, 0, 5000);
                this.scene.add(sol);
                this.entities.landmarks.push({mesh: sol, name: 'LIBERTY'});
            }

            createShip() {
                const group = new THREE.Group();
                group.add(new THREE.Mesh(new THREE.BoxGeometry(60, 25, 200), new THREE.MeshStandardMaterial({color:0x444444})));
                const tower = new THREE.Mesh(new THREE.BoxGeometry(35, 40, 50), new THREE.MeshStandardMaterial({color:0x555555}));
                tower.position.set(0, 30, -30); group.add(tower);
                return group;
            }

            createAirliner() {
                const group = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color:0xffffff, emissive: 0x111111});
                const body = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 150, 12), mat);
                body.rotation.x = Math.PI/2;
                const wings = new THREE.Mesh(new THREE.BoxGeometry(140, 1.5, 40), mat);
                wings.position.z = 10; group.add(body, wings);
                return group;
            }

            createPlayer() {
                this.player = new THREE.Group();
                const hull = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, metalness: 0.85, roughness: 0.15 });
                const dark = new THREE.MeshStandardMaterial({ color: 0x333340, metalness: 0.9, roughness: 0.2 });
                const glow = new THREE.MeshStandardMaterial({ color: 0x00f2ff, emissive: 0x00f2ff, emissiveIntensity: 0.8 });
                const canopyMat = new THREE.MeshStandardMaterial({ color: 0x00ccff, transparent: true, opacity: 0.6, metalness: 0.3 });
                const engineGlow = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.7 });

                if(this.state.unit === 'JET') {
                    // Nose cone
                    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.5, 3, 8), hull);
                    nose.rotation.x = -Math.PI/2; nose.position.z = -4.5;
                    // Main fuselage
                    const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.9, 6, 10), hull);
                    fuse.rotation.x = Math.PI/2; fuse.position.z = -0.5;
                    // Cockpit canopy
                    const canopy = new THREE.Mesh(new THREE.SphereGeometry(0.55, 8, 6, 0, Math.PI*2, 0, Math.PI/2), canopyMat);
                    canopy.position.set(0, 0.55, -2.8);
                    // Delta wings
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0, 0); wingShape.lineTo(5.5, -2); wingShape.lineTo(4.5, -2.5); wingShape.lineTo(0, -0.8);
                    const wingGeo = new THREE.ExtrudeGeometry(wingShape, {depth: 0.08, bevelEnabled: false});
                    const wingL = new THREE.Mesh(wingGeo, hull); wingL.position.set(0, -0.1, 0); wingL.rotation.x = Math.PI/2;
                    const wingR = new THREE.Mesh(wingGeo, hull); wingR.position.set(0, -0.1, 0); wingR.rotation.x = Math.PI/2; wingR.scale.x = -1;
                    // Wing tip accents
                    const tipL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.06, 0.8), glow); tipL.position.set(5.2, 0, 1.5);
                    const tipR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.06, 0.8), glow); tipR.position.set(-5.2, 0, 1.5);
                    // Vertical tail fin
                    const tailFin = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.2, 1.8), dark);
                    tailFin.position.set(0, 1.1, 2);
                    // Horizontal stabilizers
                    const stabL = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.06, 1.2), hull); stabL.position.set(1.3, 0, 2.2);
                    const stabR = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.06, 1.2), hull); stabR.position.set(-1.3, 0, 2.2);
                    // Engine nacelles
                    const engL = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 2.5, 8), dark);
                    engL.rotation.x = Math.PI/2; engL.position.set(1.2, -0.2, 1);
                    const engR = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 2.5, 8), dark);
                    engR.rotation.x = Math.PI/2; engR.position.set(-1.2, -0.2, 1);
                    // Afterburner glow
                    this.exhaustL = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2, 6), engineGlow);
                    this.exhaustL.rotation.x = -Math.PI/2; this.exhaustL.position.set(1.2, -0.2, 3.2);
                    this.exhaustR = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2, 6), engineGlow);
                    this.exhaustR.rotation.x = -Math.PI/2; this.exhaustR.position.set(-1.2, -0.2, 3.2);
                    // Fuselage accent stripe
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 5), glow);
                    stripe.position.set(0, 0.75, -0.5);

                    this.player.add(nose, fuse, canopy, wingL, wingR, tipL, tipR, tailFin, stabL, stabR, engL, engR, this.exhaustL, this.exhaustR, stripe);
                } else {
                    // UFO - sci-fi saucer
                    const saucer = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 0.8, 24), hull);
                    const rim = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.15, 6, 24), glow);
                    rim.rotation.x = Math.PI/2;
                    const dome = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 12, 0, Math.PI*2, 0, Math.PI/2), canopyMat);
                    dome.position.y = 0.4;
                    const bottom = new THREE.Mesh(new THREE.ConeGeometry(1.8, 1, 12), dark);
                    bottom.position.y = -0.8; bottom.rotation.x = Math.PI;
                    this.exhaustL = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.3, 12), engineGlow);
                    this.exhaustL.position.y = -1.3;
                    this.exhaustR = this.exhaustL; // share reference for UFO
                    this.player.add(saucer, rim, dome, bottom, this.exhaustL);
                }
                this.scene.add(this.player);
                this.player.position.set(0, 15, 1000);
                this.speed = 0;
            }

            spawnUnit(isAlly) {
                const unit = new THREE.Group();
                const baseColor = isAlly ? 0x00aa44 : 0x660000;
                const accentColor = isAlly ? 0x00ff88 : 0xff3300;
                const mat = new THREE.MeshStandardMaterial({ color: baseColor, metalness: 0.7, roughness: 0.3 });
                const accentMat = new THREE.MeshStandardMaterial({ color: accentColor, emissive: accentColor, emissiveIntensity: 0.4 });
                // Fuselage
                const body = new THREE.Mesh(new THREE.ConeGeometry(0.5, 5, 8), mat);
                body.rotation.x = -Math.PI/2;
                // Wings
                const wings = new THREE.Mesh(new THREE.BoxGeometry(7, 0.08, 2), mat);
                wings.position.z = 0.5;
                // Tail
                const tail = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.5, 1.2), mat);
                tail.position.set(0, 0.75, 2);
                // Engine glow
                const eng = new THREE.Mesh(new THREE.ConeGeometry(0.25, 1.2, 6), new THREE.MeshBasicMaterial({color: accentColor, transparent:true, opacity:0.6}));
                eng.rotation.x = -Math.PI/2; eng.position.z = 3;
                // Wing tips
                const tL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.04, 0.6), accentMat); tL.position.set(3.3, 0, 0.8);
                const tR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.04, 0.6), accentMat); tR.position.set(-3.3, 0, 0.8);
                unit.add(body, wings, tail, eng, tL, tR);

                const x = (Math.random()-0.5)*15000; const z = (Math.random()-0.5)*15000;
                unit.position.set(x, 500+Math.random()*1500, z);
                this.scene.add(unit);
                // AI behavior type: 0=chaser, 1=flanker, 2=diver
                const aiType = Math.floor(Math.random()*3);
                const data = { mesh: unit, isAlly, hp: 3, aiType, phase: 0, phaseTimer: 0,
                    offset: new THREE.Vector3((Math.random()-0.5)*120, (Math.random()-0.5)*60, 60 + Math.random()*60),
                    baseSpeed: 1.5 + this.state.difficulty * 0.5 };
                if(isAlly) this.entities.allies.push(data); else this.entities.enemies.push(data);
            }

            setupUI() {
                const bnd = (id, key) => document.getElementById(id).querySelectorAll('.opt-btn').forEach(b => b.onclick = () => {
                    document.getElementById(id).querySelector('.active').classList.remove('active');
                    b.classList.add('active'); this.state[key] = b.dataset.val;
                });
                bnd('unit-select', 'unit'); bnd('diff-select', 'difficulty');

                // Level descriptions
                const levelDescs = {
                    1: 'Lv1: 10kills, slow, strong auto-aim, HP 8',
                    2: 'Lv2: 20kills, moderate speed, good aim, HP 7',
                    3: 'Lv3: 30kills, fast, medium aim, HP 6',
                    4: 'Lv4: 40kills, very fast, weak aim, HP 5',
                    5: 'Lv5: 50kills, extreme speed, manual aim, HP 4'
                };
                const descEl = document.getElementById('level-desc');
                document.getElementById('diff-select').querySelectorAll('.opt-btn').forEach(b => {
                    b.addEventListener('click', () => { descEl.textContent = levelDescs[b.dataset.val]; });
                });

                document.getElementById('start-btn').onclick = () => this.start();

                // Spring-back Lever: up=accelerate, down=decelerate, release=hold speed
                this.input.thrust = 0.5; // start at mid
                this.leverActive = false;
                const leverZone = document.getElementById('speed-lever-zone');
                const leverTrack = document.getElementById('lever-track');
                const leverHandle = document.getElementById('lever-handle');
                const handleLever = (e) => {
                    e.preventDefault();
                    const touch = e.touches ? e.touches[0] : e;
                    const rect = leverTrack.getBoundingClientRect();
                    const y = Math.max(0, Math.min(1, (touch.clientY - rect.top) / rect.height));
                    // y=0 top (accelerate), y=1 bottom (decelerate), 0.5=center
                    leverHandle.style.top = (y * 100) + '%';
                    this.leverInput = 0.5 - y; // +0.5=full accel, -0.5=full decel
                    this.leverActive = true;
                };
                leverZone.addEventListener('touchstart', handleLever, {passive: false});
                leverZone.addEventListener('touchmove', handleLever, {passive: false});
                leverZone.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    leverHandle.style.top = '50%';
                    this.leverInput = 0;
                    this.leverActive = false;
                }, {passive: false});

                // Joystick - dynamic mode with always-visible CSS guide
                const jZone = document.getElementById('joystick-zone');
                const radarLeft = window.innerWidth / 2 - 65;
                jZone.style.left = (radarLeft - 140) + 'px';
                this.joystickActive = false;
                nipplejs.create({
                    zone: jZone,
                    mode: 'dynamic',
                    color: 'cyan',
                    size: 86
                }).on('move', (e, d) => {
                    this.input.joystick.x = d.vector.x;
                    this.input.joystick.y = d.vector.y;
                    this.joystickActive = true;
                }).on('end', () => { this.input.joystick = {x:0, y:0}; this.joystickActive = false; });

                document.getElementById('fire-btn').ontouchstart = (e) => { e.preventDefault(); this.input.firing = true; };
                document.getElementById('fire-btn').ontouchend = () => this.input.firing = false;

                // Pause toggle (P key)
                window.addEventListener('keydown', (e) => {
                    if(e.key === 'p' || e.key === 'P') {
                        if(!this.state.active) return;
                        this.state.paused = !this.state.paused;
                        document.getElementById('msg-box').innerText = this.state.paused ? "PAUSED" : "";
                    }
                });
            }

            start() {
                this.state.difficulty = parseInt(this.state.difficulty);
                this.state.targetKills = 10 * this.state.difficulty;
                this.initAudio(); this.initWorld(); this.createPlayer();
                this.state.active = true; this.state.takeoff = true;
                this.playerHP = 3 + (6 - this.state.difficulty); // HP: 8 at lv1, 4 at lv5
                this.input.thrust = 1.0; // auto full thrust for takeoff
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
                document.getElementById('msg-box').innerText = "AUTO TAKEOFF...";
                for(let i=0; i<this.state.targetKills; i++) this.spawnUnit(false);
                for(let i=0; i<2; i++) this.spawnUnit(true);
                this.timerInterval = setInterval(() => {
                    if(this.state.active && !this.state.paused) {
                        this.state.timeLeft--;
                        if(this.state.timeLeft <= 0) this.gameOver(false);
                    }
                }, 1000);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                if (!this.state.active || this.state.paused) {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }
                const delta = Math.min(this.clock.getDelta(), 0.1);

                // Lever: update thrust (clamped 0~1)
                if(this.leverInput) {
                    this.input.thrust = Math.max(0, Math.min(1, this.input.thrust + this.leverInput * delta * 1.5));
                }
                if(this.audio.engine) {
                    if(this.input.thrust > 0.05 && !this.audio.engine.isPlaying) this.audio.engine.play();
                    if(this.audio.engine.isPlaying) this.audio.engine.setPlaybackRate(0.6 + this.input.thrust);
                }

                if(this.state.takeoff) {
                    // Auto takeoff: forced full thrust, 2x acceleration (half time)
                    this.input.thrust = 1.0;
                    this.speed = THREE.MathUtils.lerp(this.speed, 4.5, 0.06);
                    this.player.translateZ(-this.speed);
                    if(this.speed > 2.0) {
                        this.player.rotateX(0.8 * delta);
                        if(this.player.position.y > 150) {
                            this.state.takeoff = false;
                            this.input.thrust = 0.5; // restore to mid after takeoff
                            document.getElementById('msg-box').innerText = "";
                        }
                    }
                } else {
                    const pitch = this.input.joystick.y;
                    const roll = -this.input.joystick.x;

                    if(this.joystickActive && (Math.abs(pitch) > 0.05 || Math.abs(roll) > 0.05)) {
                        // Manual control
                        this.player.rotateX(pitch * 2.5 * delta);
                        this.player.rotateZ(roll * 3.5 * delta);
                        this.player.rotateY(-roll * 1.5 * delta);
                    } else {
                        // Auto-track nearest enemy when joystick idle
                        let nearest = null, nearDist = Infinity;
                        this.entities.enemies.forEach(en => {
                            const d = en.mesh.position.distanceTo(this.player.position);
                            if(d < nearDist) { nearDist = d; nearest = en; }
                        });
                        if(nearest && nearDist < 15000) {
                            const toEnemy = nearest.mesh.position.clone().sub(this.player.position).normalize();
                            const trackQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), toEnemy);
                            this.player.quaternion.slerp(trackQuat, 0.02);
                        } else {
                            const targetQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, this.player.rotation.y, 0));
                            this.player.quaternion.slerp(targetQuat, 0.04);
                        }
                    }
                    this.speed = THREE.MathUtils.lerp(this.speed, this.input.thrust * (6.0 + this.state.difficulty), 0.05);
                    this.player.translateZ(-this.speed);
                }

                this.entities.allies.forEach(al => {
                    const targetPos = this.player.position.clone().add(al.offset.clone().applyQuaternion(this.player.quaternion));
                    al.mesh.position.lerp(targetPos, 0.08); al.mesh.quaternion.slerp(this.player.quaternion, 0.08);
                });

                // Enemy AI - diverse combat behaviors
                const time = this.clock.elapsedTime;
                this.entities.enemies.forEach(en => {
                    const toPlayer = this.player.position.clone().sub(en.mesh.position);
                    const dist = toPlayer.length();
                    const dirN = toPlayer.clone().normalize();
                    en.phaseTimer = (en.phaseTimer || 0) + delta;
                    const spd = en.baseSpeed * delta * 60;
                    const turnRate = 0.025 + this.state.difficulty * 0.008;

                    if(en.aiType === 0) {
                        // CHASER: direct pursuit, break off at close range then loop back
                        if(dist < 400) {
                            // Overshoot and loop back
                            en.mesh.translateZ(-spd * 1.5);
                            en.mesh.rotateX(2.5 * delta);
                        } else {
                            const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), dirN);
                            en.mesh.quaternion.slerp(tq, turnRate);
                            en.mesh.translateZ(-spd);
                        }
                    } else if(en.aiType === 1) {
                        // FLANKER: circle around player, attack from side
                        const perpX = dirN.z; const perpZ = -dirN.x;
                        const orbitDir = new THREE.Vector3(perpX, dirN.y * 0.3, perpZ).normalize();
                        if(dist > 2000) orbitDir.lerp(dirN, 0.6);
                        else if(dist < 600) orbitDir.lerp(dirN, -0.3);
                        const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), orbitDir);
                        en.mesh.quaternion.slerp(tq, turnRate * 1.2);
                        en.mesh.translateZ(-spd * 1.1);
                    } else {
                        // DIVER: climb high then dive-bomb, repeat
                        if(en.phaseTimer < 3) {
                            // Climb phase
                            const climbTarget = this.player.position.clone().add(new THREE.Vector3(0, 800, 0));
                            const climbDir = climbTarget.sub(en.mesh.position).normalize();
                            const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), climbDir);
                            en.mesh.quaternion.slerp(tq, turnRate);
                            en.mesh.translateZ(-spd * 0.8);
                        } else {
                            // Dive attack
                            const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), dirN);
                            en.mesh.quaternion.slerp(tq, turnRate * 1.8);
                            en.mesh.translateZ(-spd * 2.0);
                            if(dist < 300 || en.phaseTimer > 6) en.phaseTimer = 0;
                        }
                    }

                    // Evasive roll for visual flair
                    if(dist < 1500) en.mesh.rotateZ(Math.sin(time * 3 + en.aiType) * 0.8 * delta);

                    // Altitude floor
                    if(en.mesh.position.y < 100) en.mesh.position.y = 100;

                    // Enemy fires at player
                    if(!en.fireTimer) en.fireTimer = Math.random() * 2;
                    en.fireTimer -= delta;
                    if(en.fireTimer <= 0 && dist < 3000) {
                        en.fireTimer = 2.0 - this.state.difficulty * 0.25;
                        // Muzzle flash
                        const flash = new THREE.Mesh(new THREE.SphereGeometry(1.5, 4, 4), new THREE.MeshBasicMaterial({color:0xff6600, transparent:true, opacity:0.9}));
                        flash.position.copy(en.mesh.position); this.scene.add(flash);
                        this.entities.particles.push({ mesh: flash, vel: new THREE.Vector3(0,0,0), life: 0.1 });
                        // Bullet with lead prediction
                        const eb = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 4), new THREE.MeshBasicMaterial({color:0xff4444}));
                        eb.position.copy(en.mesh.position); this.scene.add(eb);
                        const predict = this.player.position.clone().add(new THREE.Vector3(0,0,-this.speed * 8).applyQuaternion(this.player.quaternion));
                        const edir = predict.sub(en.mesh.position).normalize().multiplyScalar(45);
                        this.entities.bullets.push({ mesh: eb, life: 1.5, vel: edir, isEnemy: true });
                    }
                });

                this.entities.ships.forEach(s => { s.mesh.translateZ(s.speed); if(s.mesh.position.z > 40000) s.mesh.position.z = -40000; });
                if(this.entities.birds) this.entities.birds.forEach(b => { b.mesh.translateZ(-b.speed); if(b.mesh.position.z < -20000) b.mesh.position.z = 20000; });
                this.entities.airliners.forEach(a => { 
                    a.mesh.translateZ(a.speed); if(a.mesh.position.z > 40000) a.mesh.position.z = -40000; 
                    a.trailTimer += delta; if(a.trailTimer > 0.15) { this.createTrail(a.mesh.position.clone().add(new THREE.Vector3(0,0,10))); a.trailTimer = 0; }
                });

                if(!this.fireTimer) this.fireTimer = 0;
                this.fireTimer -= delta;
                if(this.input.firing && this.fireTimer <= 0) {
                    this.fireTimer = 0.15;
                    if(this.audio.laser) { if(this.audio.laser.isPlaying) this.audio.laser.stop(); this.audio.laser.play(); }
                    // Dual wing-mounted fire (alternate left/right)
                    this.fireToggle = !this.fireToggle;
                    const wingOffset = new THREE.Vector3(this.fireToggle ? 3.5 : -3.5, -0.1, -2).applyQuaternion(this.player.quaternion);
                    const b = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 5), new THREE.MeshBasicMaterial({color:0x00f2ff}));
                    b.position.copy(this.player.position).add(wingOffset); b.quaternion.copy(this.player.quaternion);
                    this.scene.add(b);
                    // Muzzle flash
                    const mf = new THREE.Mesh(new THREE.SphereGeometry(0.6, 4, 4), new THREE.MeshBasicMaterial({color:0x88ffff, transparent:true, opacity:0.9}));
                    mf.position.copy(b.position); this.scene.add(mf);
                    this.entities.particles.push({ mesh: mf, vel: new THREE.Vector3(0,0,0), life: 0.08 });
                    // Auto-aim: guide bullet toward nearest enemy (stronger at lower difficulty)
                    let bulletDir = new THREE.Vector3(0,0,-50).applyQuaternion(this.player.quaternion);
                    const aimStrength = (6 - this.state.difficulty) * 0.15; // 0.75 at lv1, 0.15 at lv5
                    let nearestDist = Infinity, nearestEnemy = null;
                    this.entities.enemies.forEach(en => {
                        const d = en.mesh.position.distanceTo(this.player.position);
                        if(d < nearestDist && d < 5000) { nearestDist = d; nearestEnemy = en; }
                    });
                    if(nearestEnemy) {
                        const toEnemy = nearestEnemy.mesh.position.clone().sub(this.player.position).normalize().multiplyScalar(50);
                        bulletDir.lerp(toEnemy, aimStrength);
                    }
                    this.entities.bullets.push({ mesh: b, life: 1.8, vel: bulletDir });
                }

                for(let i=this.entities.bullets.length-1; i>=0; i--) {
                    const b = this.entities.bullets[i]; b.mesh.position.add(b.vel); b.life -= delta;
                    this.entities.enemies.forEach((en, ei) => {
                        if(b.mesh.position.distanceTo(en.mesh.position) < 60) {
                            if(this.audio.explosion) { if(this.audio.explosion.isPlaying) this.audio.explosion.stop(); this.audio.explosion.play(); }
                            this.createExplosion(en.mesh.position);
                            this.scene.remove(en.mesh); this.entities.enemies.splice(ei, 1);
                            b.life = 0; this.state.kills++;
                            if(this.state.kills >= this.state.targetKills) this.gameOver(true);
                        }
                    });
                    // Enemy bullet hits player
                    if(b.isEnemy && this.player && b.mesh.position.distanceTo(this.player.position) < 30) {
                        this.createExplosion(this.player.position.clone());
                        if(this.audio.explosion) { if(this.audio.explosion.isPlaying) this.audio.explosion.stop(); this.audio.explosion.play(); }
                        b.life = 0;
                        this.shakeAmount = 3.0; // camera shake on hit
                        if(!this.playerHP) this.playerHP = 3 + (6 - this.state.difficulty);
                        this.playerHP--;
                        if(this.playerHP <= 0) this.gameOver(false);
                    }
                    if(b.life <= 0) { this.scene.remove(b.mesh); this.entities.bullets.splice(i, 1); }
                }

                // Radar Update
                const dots = document.getElementById('radar-dots'); dots.innerHTML = '';
                [...this.entities.enemies, ...this.entities.allies, ...this.entities.landmarks].forEach(ent => {
                    const dx = ent.mesh.position.x - this.player.position.x;
                    const dz = ent.mesh.position.z - this.player.position.z;
                    if(dx*dx + dz*dz < 10000*10000) {
                        const dot = document.createElement('div'); dot.className = 'radar-dot';
                        dot.style.left = (dx / 10000) * 65 + 65 + 'px'; dot.style.top = (dz / 10000) * 65 + 65 + 'px';
                        dot.style.backgroundColor = ent.isAlly ? 'var(--ally)' : (ent.name ? 'white' : 'var(--danger)');
                        dots.appendChild(dot);
                    }
                });

                if(Math.abs(this.player.position.x) > 40000) this.player.position.x *= -0.99;
                if(Math.abs(this.player.position.z) > 40000) this.player.position.z *= -0.99;

                // Afterburner effect - scale with thrust
                if(this.exhaustL) {
                    const s = 0.3 + this.input.thrust * 1.5 + Math.sin(time * 20) * 0.2;
                    this.exhaustL.scale.set(1, s, 1);
                    if(this.exhaustR !== this.exhaustL) this.exhaustR.scale.set(1, s, 1);
                }

                // Player engine trail
                if(!this.state.takeoff && this.speed > 2 && Math.random() < 0.3) {
                    const trailPos = this.player.position.clone().add(new THREE.Vector3(0, -0.2, 3).applyQuaternion(this.player.quaternion));
                    const t = new THREE.Mesh(new THREE.SphereGeometry(0.5, 4, 4), new THREE.MeshBasicMaterial({color:0x4488ff, transparent:true, opacity:0.5}));
                    t.position.copy(trailPos); this.scene.add(t);
                    this.entities.particles.push({ mesh: t, vel: new THREE.Vector3(0,0,0), life: 0.6 });
                }

                // Camera with shake on hit
                if(!this.shakeAmount) this.shakeAmount = 0;
                this.shakeAmount *= 0.9;
                const shakeOff = new THREE.Vector3((Math.random()-0.5)*this.shakeAmount, (Math.random()-0.5)*this.shakeAmount, 0);
                const camOff = new THREE.Vector3(0, 3.8, 13 + this.speed*2.5).applyQuaternion(this.player.quaternion);
                this.camera.position.lerp(this.player.position.clone().add(camOff).add(shakeOff), 0.15);
                this.camera.lookAt(this.player.position.clone().add(new THREE.Vector3(0,0,-25).applyQuaternion(this.player.quaternion)));

                // Particle update
                for(let i=this.entities.particles.length-1; i>=0; i--) {
                    const p = this.entities.particles[i];
                    p.mesh.position.add(p.vel);
                    p.life -= delta;
                    p.mesh.material.opacity = Math.max(0, p.life / (p.isSmoke ? 2.5 : 2.0));
                    if(p.life <= 0) { this.scene.remove(p.mesh); this.entities.particles.splice(i, 1); }
                }

                if(!this.state.takeoff && this.player.position.y < 5) this.gameOver(false);

                document.getElementById('alt-val').innerText = Math.floor(this.player.position.y);
                document.getElementById('spd-val').innerText = (this.speed * 180).toFixed(0);
                document.getElementById('kill-val').innerText = this.state.kills;
                document.getElementById('target-val').innerText = this.state.targetKills;
                document.getElementById('timer-val').innerText = this.state.timeLeft;
                this.renderer.render(this.scene, this.camera);
            }

            createExplosion(pos) {
                // Core flash
                const flash = new THREE.Mesh(new THREE.SphereGeometry(12, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1.0 }));
                flash.position.copy(pos); this.scene.add(flash);
                this.entities.particles.push({ mesh: flash, vel: new THREE.Vector3(0,0,0), life: 0.15 });
                // Fire + smoke + sparks
                for(let i=0; i<40; i++) {
                    const r = Math.random();
                    let color, size, life, speed;
                    if(r < 0.3) { color = 0xff4400; size = 3; life = 0.8; speed = 18; } // fire core
                    else if(r < 0.6) { color = 0xffaa00; size = 2; life = 1.0; speed = 14; } // fire outer
                    else if(r < 0.8) { color = 0x555555; size = 5; life = 2.5; speed = 6; } // smoke
                    else { color = 0xffff44; size = 0.5; life = 0.6; speed = 25; } // sparks
                    const p = new THREE.Mesh(new THREE.SphereGeometry(size, 6, 6), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1.0 }));
                    p.position.copy(pos); this.scene.add(p);
                    const vel = new THREE.Vector3((Math.random()-0.5)*speed, (Math.random()-0.5)*speed + 3, (Math.random()-0.5)*speed);
                    this.entities.particles.push({ mesh: p, vel, life, isSmoke: r >= 0.6 && r < 0.8 });
                }
                // Debris chunks
                for(let i=0; i<5; i++) {
                    const d = new THREE.Mesh(new THREE.BoxGeometry(1+Math.random()*2, 0.5, 1+Math.random()*2), new THREE.MeshStandardMaterial({color:0x333333}));
                    d.position.copy(pos); this.scene.add(d);
                    this.entities.particles.push({ mesh: d, vel: new THREE.Vector3((Math.random()-0.5)*15, Math.random()*10, (Math.random()-0.5)*15), life: 2.0 });
                }
            }

            createTrail(pos) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(3, 4, 4), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 }));
                p.position.copy(pos); this.scene.add(p);
                this.entities.particles.push({ mesh: p, vel: new THREE.Vector3(0,0,0), life: 2.0 });
            }

            gameOver(success) {
                this.state.active = false; clearInterval(this.timerInterval);
                const score = this.state.kills * 100 * this.state.difficulty + (success ? this.state.timeLeft * 50 : 0);
                const ratio = this.state.kills / this.state.targetKills;
                let recLevel = this.state.difficulty;
                if(success && ratio >= 1 && this.state.timeLeft > 20) recLevel = Math.min(5, recLevel + 1);
                else if(!success && ratio < 0.3) recLevel = Math.max(1, recLevel - 1);

                document.getElementById('over-title').innerText = success ? "MISSION COMPLETE" : "MISSION FAILED";
                let stats = `ACE LEVEL ${this.state.difficulty} | KILLS: ${this.state.kills} / ${this.state.targetKills}\nSCORE: ${score}`;
                if(recLevel !== this.state.difficulty) stats += `\nRECOMMENDED LEVEL: ${recLevel}`;
                document.getElementById('over-stats').innerText = stats;
                document.getElementById('over-screen').style.display = 'flex';
                if(this.audio.engine) this.audio.engine.stop();
            }
        }
        window.onload = () => new Game();
    </script>
</body>
</html>