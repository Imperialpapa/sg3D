<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Skyline Ace: Precise Controls</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;500;700&display=swap');
        :root { --accent: #00f2ff; --danger: #ff4444; --ally: #00ff88; --glass: rgba(0, 0, 0, 0.7); }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Quicksand', sans-serif; touch-action: none; color: white; }
        
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, rgba(10,30,70,0.95), #000);
            z-index: 2000; transition: opacity 0.8s;
        }
        .card {
            background: var(--glass); backdrop-filter: blur(25px);
            padding: 25px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            text-align: center; width: 80%; max-width: 380px;
        }
        h1 { font-weight: 300; letter-spacing: 6px; margin: 0 0 15px; font-size: 1.8rem; }
        .opt-btn {
            flex: 1; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2);
            color: white; border-radius: 8px; cursor: pointer; font-size: 11px;
        }
        .opt-btn.active { background: var(--accent); border-color: var(--accent); color: #000; font-weight: 700; }
        .start-btn {
            width: 100%; margin-top: 20px; padding: 15px; border-radius: 50px;
            background: #fff; color: #000; border: none; font-weight: 700; cursor: pointer;
        }

        /* HUD & Controls Container */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; display: none; }
        .hud-el { position: absolute; padding: 8px 12px; background: var(--glass); border-radius: 8px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .hud-tl { top: 15px; left: 15px; border-left: 3px solid var(--accent); }
        .hud-tr { top: 15px; right: 15px; text-align: right; border-right: 3px solid var(--danger); }
        .hud-tm { top: 15px; left: 50%; transform: translateX(-50%); text-align: center; width: 100px; }
        
        /* Central Radar - Largest UI element */
        #radar-ui {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 130px; height: 130px; border-radius: 50%; border: 2px solid rgba(0,242,255,0.35);
            background: radial-gradient(circle, rgba(0,30,30,0.6) 0%, rgba(0,10,10,0.8) 100%);
            backdrop-filter: blur(4px); pointer-events: none;
        }
        .radar-dot { position: absolute; width: 4px; height: 4px; border-radius: 50%; transform: translate(-50%, -50%); }
        #radar-player { position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; background: white; border-radius: 50%; transform: translate(-50%, -50%); }

        /* Left Control: Joystick zone with always-visible guide */
        #joystick-zone {
            position: absolute; bottom: 20px; width: 130px; height: 130px;
            pointer-events: auto; z-index: 1000; touch-action: none;
        }
        #joystick-guide {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 80px; height: 80px; border-radius: 50%;
            border: 2px solid rgba(0,242,255,0.3);
            background: radial-gradient(circle, rgba(0,242,255,0.06) 0%, transparent 70%);
            pointer-events: none;
        }
        #joystick-guide::after {
            content: ''; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 24px; height: 24px; border-radius: 50%;
            background: rgba(0,242,255,0.25); border: 1px solid rgba(0,242,255,0.4);
        }

        /* Right Controls: Lever above Fire */
        #speed-lever-zone {
            position: absolute; right: 22px; bottom: 90px;
            height: 120px; width: 50px; pointer-events: auto;
            display: flex; flex-direction: column; align-items: center;
            z-index: 1000; touch-action: none;
        }
        #lever-track {
            width: 8px; height: 100px; background: rgba(255,255,255,0.15);
            border-radius: 4px; position: relative; border: 1px solid rgba(255,255,255,0.2);
        }
        #lever-handle {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 20px; background: var(--accent); border-radius: 4px;
            box-shadow: 0 0 12px var(--accent), 0 0 4px rgba(0,242,255,0.5);
            transition: top 0.2s ease-out;
        }
        #lever-label-up, #lever-label-dn {
            font-size: 7px; opacity: 0.5; letter-spacing: 1px; position: absolute; width: 100%; text-align: center;
        }
        #lever-label-up { top: -14px; }
        #lever-label-dn { bottom: -14px; }

        #fire-btn {
            position: absolute; bottom: 15px; right: 15px; width: 65px; height: 65px;
            border-radius: 10px; background: rgba(255,50,50,0.3); border: 2px solid var(--danger);
            display: flex; justify-content: center; align-items: center; pointer-events: auto;
            color: white; font-weight: 700; z-index: 1000; font-size: 13px;
            box-shadow: 0 0 10px rgba(255,68,68,0.3);
        }

        #auto-fire-btn {
            position: absolute; bottom: 85px; right: 15px; width: 65px; height: 28px;
            border-radius: 6px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2);
            display: flex; justify-content: center; align-items: center; pointer-events: auto;
            color: rgba(255,255,255,0.5); font-weight: 500; z-index: 1000; font-size: 9px; letter-spacing: 1px;
        }
        #auto-fire-btn.active { background: rgba(0,242,255,0.2); border-color: var(--accent); color: var(--accent); }

        /* Target lock-on reticle */
        #target-reticle {
            position: absolute; pointer-events: none; display: none; z-index: 150;
        }
        #target-reticle .reticle-ring {
            width: 60px; height: 60px; border: 2px solid var(--danger); border-radius: 50%;
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            animation: reticle-spin 2s linear infinite;
        }
        #target-reticle .reticle-cross { position: absolute; background: var(--danger); }
        #target-reticle .reticle-cross.h { width: 20px; height: 1px; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        #target-reticle .reticle-cross.v { width: 1px; height: 20px; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        #target-reticle .reticle-info {
            position: absolute; top: 38px; left: 50%; transform: translateX(-50%);
            font-size: 9px; color: var(--danger); white-space: nowrap; letter-spacing: 1px;
        }
        #target-reticle.locked .reticle-ring { border-color: #00ff44; box-shadow: 0 0 12px rgba(0,255,68,0.5); }
        #target-reticle.locked .reticle-cross { background: #00ff44; }
        #target-reticle.locked .reticle-info { color: #00ff44; }
        @keyframes reticle-spin { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

        #msg-box { position: absolute; top: 120px; left: 50%; transform: translateX(-50%); font-size: 18px; color: var(--accent); text-align: center; pointer-events: none; width: 100%; }
        #damage-flash { position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(255,0,0,0.35); pointer-events:none; opacity:0; transition:opacity 0.3s; z-index:90; }
        #damage-vignette { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; opacity:0; z-index:89;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(255,0,0,0.5) 100%); transition:opacity 0.5s; }
        #combo-text { position: absolute; top: 35%; left: 50%; transform: translate(-50%,-50%); font-size: 28px; font-weight:700;
            pointer-events:none; z-index:160; opacity:0; transition: opacity 0.4s, transform 0.4s; text-shadow: 0 0 20px currentColor; letter-spacing:3px; }
        #powerup-indicator { position:absolute; top:95px; left:15px; pointer-events:none; font-size:10px; letter-spacing:1px; }
        #powerup-indicator .pu-active { padding:3px 8px; border-radius:4px; margin-bottom:3px; font-weight:700; }
    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <div class="card">
            <h1>SKYLINE ACE</h1>
            <div style="text-align:left; margin-bottom:15px;">
                <div style="font-size:9px; opacity:0.6; letter-spacing:2px; margin-bottom:5px;">UNIT</div>
                <div style="display:flex; gap:10px;" id="unit-select">
                    <button class="opt-btn active" data-val="JET">JET</button>
                    <button class="opt-btn" data-val="UFO">UFO</button>
                </div>
            </div>
            <div style="text-align:left; margin-bottom:15px;">
                <div style="font-size:9px; opacity:0.6; letter-spacing:2px; margin-bottom:5px;">ACE LEVEL</div>
                <div style="display:flex; gap:5px;" id="diff-select">
                    <button class="opt-btn active" data-val="1">1</button>
                    <button class="opt-btn" data-val="2">2</button>
                    <button class="opt-btn" data-val="3">3</button>
                    <button class="opt-btn" data-val="4">4</button>
                    <button class="opt-btn" data-val="5">5</button>
                </div>
            </div>
            <div id="level-desc" style="text-align:left; margin-bottom:12px; font-size:10px; opacity:0.7; line-height:1.6; padding:8px; background:rgba(255,255,255,0.03); border-radius:8px; border-left:2px solid var(--accent);">
                Lv1: 5kills | Easy | strong auto-aim | HP 15
            </div>
            <div style="text-align:left; margin-bottom:12px;">
                <div style="font-size:9px; opacity:0.6; letter-spacing:2px; margin-bottom:5px;">CONTROLS</div>
                <div style="font-size:9px; opacity:0.5; line-height:1.8;">
                    <span style="color:var(--accent);">LEFT</span> Joystick: Pitch &amp; Roll<br>
                    <span style="color:var(--accent);">RIGHT</span> Lever Up/Down: Accel/Decel<br>
                    <span style="color:var(--danger);">FIRE</span> Button: Shoot (auto-aim)<br>
                    <span style="color:white;">AUTO</span> No input = track nearest enemy<br>
                    <span style="color:white;">P key</span> Pause toggle
                </div>
            </div>
            <div id="top-scores" style="text-align:left; margin-bottom:12px; display:none;">
                <div style="font-size:9px; opacity:0.6; letter-spacing:2px; margin-bottom:5px;">TOP SCORES</div>
                <div id="scores-list" style="font-size:10px; opacity:0.6; line-height:1.6; padding:8px; background:rgba(255,255,255,0.03); border-radius:8px; border-left:2px solid #ffdd00; max-height:120px; overflow-y:auto;"></div>
            </div>
            <button id="start-btn" class="start-btn">INITIATE</button>
        </div>
    </div>

    <div id="over-screen" class="screen" style="display:none;">
        <div class="card">
            <h1 id="over-title" style="font-size:1.5rem;">MISSION END</h1>
            <div id="over-stats" style="margin:15px 0; font-size:14px; opacity:0.8; white-space:pre-line;"></div>
            <div id="over-buttons">
                <button onclick="location.reload()" class="start-btn">REDEPLOY</button>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <div class="hud-el hud-tl">
            <div style="font-size:8px; opacity:0.7;">ALT / SPD</div>
            <div style="font-size:16px;"><span id="alt-val">0</span> / <span id="spd-val">0</span></div>
        </div>
        <div class="hud-el" style="top:65px; left:15px; border-left:3px solid #ff4444;">
            <div style="font-size:8px; opacity:0.7;">HP</div>
            <div style="width:80px; height:8px; background:rgba(255,255,255,0.15); border-radius:4px; overflow:hidden;">
                <div id="hp-fill" style="width:100%; height:100%; background:#00ff88; border-radius:4px; transition:width 0.3s;"></div>
            </div>
        </div>
        <div class="hud-el hud-tr">
            <div style="font-size:8px; opacity:0.7;">KILLS / GOAL</div>
            <div style="font-size:16px;"><span id="kill-val">0</span> / <span id="target-val">0</span></div>
        </div>
        <div class="hud-el hud-tm">
            <div style="font-size:8px; opacity:0.7;">REMAINING</div>
            <div style="font-size:16px; color:var(--danger);" id="timer-val">60</div>
        </div>
        
        <div id="radar-ui"><div id="radar-player"></div><div id="radar-dots"></div></div>
        
        <div id="speed-lever-zone">
            <div id="lever-track">
                <div id="lever-label-up">ACC</div>
                <div id="lever-handle"></div>
                <div id="lever-label-dn">DEC</div>
            </div>
        </div>
        <div id="joystick-zone"><div id="joystick-guide"></div></div>
        <div id="auto-fire-btn">AUTO</div>
        <div id="fire-btn">FIRE</div>
        <div id="target-reticle">
            <div class="reticle-ring"></div>
            <div class="reticle-cross h"></div>
            <div class="reticle-cross v"></div>
            <div class="reticle-info"></div>
        </div>
        <div id="msg-box"></div>
        <div id="damage-flash"></div>
        <div id="damage-vignette"></div>
        <div id="combo-text"></div>
        <div id="powerup-indicator"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        const SOUNDS = {
            engine: 'https://actions.google.com/sounds/v1/transportation/jet_plane_flying_loop.ogg',
            laser: 'https://actions.google.com/sounds/v1/science_fiction/low_laser_shot.ogg',
            explosion: 'https://actions.google.com/sounds/v1/explosions/distant_explosion.ogg',
            lockon: 'https://actions.google.com/sounds/v1/alarms/beep_short.ogg',
            hit: 'https://actions.google.com/sounds/v1/impacts/metal_impact.ogg',
            flyby: 'https://actions.google.com/sounds/v1/transportation/jet_flyby.ogg'
        };
        const DIFF = [
            null,
            { kills: 5,  hp: 15, maxSpd: 10, enSpd: 1.0, enTurn: 0.012, enFire: 4.0, aim: 0.90, track: 0.05, predict: 2 },
            { kills: 10, hp: 12, maxSpd: 9,  enSpd: 1.5, enTurn: 0.020, enFire: 3.0, aim: 0.70, track: 0.035, predict: 4 },
            { kills: 20, hp: 8,  maxSpd: 8,  enSpd: 2.5, enTurn: 0.030, enFire: 2.0, aim: 0.45, track: 0.025, predict: 7 },
            { kills: 35, hp: 5,  maxSpd: 8,  enSpd: 3.2, enTurn: 0.045, enFire: 1.2, aim: 0.20, track: 0.015, predict: 10 },
            { kills: 50, hp: 3,  maxSpd: 7,  enSpd: 4.0, enTurn: 0.065, enFire: 0.7, aim: 0.05, track: 0.01,  predict: 12 },
        ];

        class Game {
            constructor() {
                this.state = { active: false, takeoff: false, paused: false, unit: 'JET', difficulty: 1, kills: 0, targetKills: 10, timeLeft: 300 };
                this.input = { joystick: {x:0, y:0}, thrust: 0.5, firing: false };
                this.leverInput = 0;
                this.entities = { player: null, allies: [], enemies: [], bullets: [], ships: [], airliners: [], particles: [], landmarks: [], powerups: [], buildings: [] };
                this.audio = {};
                this.initScene();
                this.setupUI();
                this.clock = new THREE.Clock();
                this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 80000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                document.body.appendChild(this.renderer.domElement);
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            initAudio() {
                const listener = new THREE.AudioListener();
                this.camera.add(listener);
                const loader = new THREE.AudioLoader();
                this.audio.engine = new THREE.Audio(listener);
                loader.load(SOUNDS.engine, buf => { this.audio.engine.setBuffer(buf); this.audio.engine.setLoop(true); this.audio.engine.setVolume(0.2); });
                this.audio.laser = new THREE.Audio(listener);
                loader.load(SOUNDS.laser, buf => { this.audio.laser.setBuffer(buf); this.audio.laser.setVolume(0.3); });
                this.audio.explosion = new THREE.Audio(listener);
                loader.load(SOUNDS.explosion, buf => { this.audio.explosion.setBuffer(buf); this.audio.explosion.setVolume(0.5); });
                this.audio.lockon = new THREE.Audio(listener);
                loader.load(SOUNDS.lockon, buf => { this.audio.lockon.setBuffer(buf); this.audio.lockon.setVolume(0.4); });
                this.audio.hit = new THREE.Audio(listener);
                loader.load(SOUNDS.hit, buf => { this.audio.hit.setBuffer(buf); this.audio.hit.setVolume(0.5); });
                this.audio.flyby = new THREE.Audio(listener);
                loader.load(SOUNDS.flyby, buf => { this.audio.flyby.setBuffer(buf); this.audio.flyby.setVolume(0.6); });
                // BGM via Web Audio API
                this.initBGM();
            }

            initBGM() {
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.bgmCtx = ctx;
                    const masterGain = ctx.createGain();
                    masterGain.gain.value = 0.08;
                    masterGain.connect(ctx.destination);
                    this.bgmGain = masterGain;
                    // Ambient drone
                    const drone = ctx.createOscillator();
                    drone.type = 'sine'; drone.frequency.value = 55;
                    const droneGain = ctx.createGain(); droneGain.gain.value = 0.6;
                    drone.connect(droneGain); droneGain.connect(masterGain);
                    drone.start();
                    // Harmonic layer
                    const harm = ctx.createOscillator();
                    harm.type = 'triangle'; harm.frequency.value = 110;
                    const harmGain = ctx.createGain(); harmGain.gain.value = 0.3;
                    harm.connect(harmGain); harmGain.connect(masterGain);
                    harm.start();
                    // Sub bass pulse
                    const sub = ctx.createOscillator();
                    sub.type = 'sine'; sub.frequency.value = 36.7;
                    const subGain = ctx.createGain(); subGain.gain.value = 0.4;
                    sub.connect(subGain); subGain.connect(masterGain);
                    sub.start();
                    // LFO for tension modulation
                    const lfo = ctx.createOscillator();
                    lfo.type = 'sine'; lfo.frequency.value = 0.15;
                    const lfoGain = ctx.createGain(); lfoGain.gain.value = 15;
                    lfo.connect(lfoGain); lfoGain.connect(harm.frequency);
                    lfo.start();
                    this.bgmDrone = drone; this.bgmHarm = harm;
                } catch(e) { /* BGM not supported */ }
            }

            initWorld() {
                const isDay = new Date().getHours() > 6 && new Date().getHours() < 19;
                this.isDay = isDay;
                this.scene.background = new THREE.Color(isDay ? 0x87ceeb : 0x050520);
                this.scene.fog = new THREE.FogExp2(isDay ? 0x99ccff : 0x0a0a2a, 0.00008);
                this.scene.add(new THREE.AmbientLight(0xffffff, isDay ? 0.8 : 0.4));
                const sun = new THREE.DirectionalLight(isDay ? 0xfff5e0 : 0x8888cc, isDay ? 1.5 : 0.4);
                sun.position.set(2000, 3000, -2000);
                this.scene.add(sun);
                if(isDay) {
                    const hemi = new THREE.HemisphereLight(0x87ceeb, 0x446633, 0.4);
                    this.scene.add(hemi);
                }

                // Sky dome with gradient
                const skyGeo = new THREE.SphereGeometry(39000, 32, 16);
                const skyColors = [];
                const col1 = new THREE.Color(isDay ? 0x1a6faa : 0x020210);
                const col2 = new THREE.Color(isDay ? 0xc8e8ff : 0x080828);
                const colH = new THREE.Color(isDay ? 0xffe8c0 : 0x0a0a2a); // horizon
                for(let i = 0; i < skyGeo.attributes.position.count; i++) {
                    const y = skyGeo.attributes.position.getY(i);
                    const t = y / 39000; // -1 to 1
                    let c;
                    if(t > 0.1) c = col2.clone().lerp(col1, Math.min(1, (t - 0.1) / 0.9));
                    else c = colH.clone().lerp(col2, Math.max(0, (t + 0.3) / 0.4));
                    skyColors.push(c.r, c.g, c.b);
                }
                skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(skyColors, 3));
                this.scene.add(new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide })));

                // Stars at night
                if(!isDay) {
                    const starsGeo = new THREE.BufferGeometry();
                    const starVerts = [];
                    for(let i = 0; i < 600; i++) {
                        const r = 38000;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI * 0.5;
                        starVerts.push(r*Math.sin(phi)*Math.cos(theta), r*Math.cos(phi), r*Math.sin(phi)*Math.sin(theta));
                    }
                    starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVerts, 3));
                    this.scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({color:0xffffff, size:25})));
                }

                // Ocean with wave geometry
                this.ocean = new THREE.Mesh(
                    new THREE.PlaneGeometry(80000, 80000, 100, 100),
                    new THREE.MeshStandardMaterial({ color: isDay ? 0x006699 : 0x001133, metalness: 0.7, roughness: 0.15, flatShading: true })
                );
                this.ocean.rotation.x = -Math.PI/2;
                this.scene.add(this.ocean);

                this.createLandmarks();

                // Ships: 5 warships, 5 cargo, 10 small boats
                for(let i=0; i<20; i++) {
                    const type = i < 5 ? 0 : i < 10 ? 1 : 2;
                    const ship = this.createShip(type);
                    ship.position.set((Math.random()-0.5)*40000, 0, (Math.random()-0.5)*40000);
                    this.scene.add(ship);
                    this.entities.ships.push({ mesh: ship, speed: 0.1 + Math.random()*0.3 });
                }
                for(let i=0; i<6; i++) {
                    const plane = this.createAirliner();
                    plane.position.set((Math.random()-0.5)*60000, 3500 + Math.random()*2500, (Math.random()-0.5)*60000);
                    this.scene.add(plane);
                    this.entities.airliners.push({ mesh: plane, speed: 2.5 + Math.random()*1.5, trailTimer: 0 });
                }

                // Layered clouds: high thin + low thick
                for(let i=0; i<50; i++) {
                    const cloud = new THREE.Group();
                    const isHigh = Math.random() > 0.5;
                    const baseSize = isHigh ? 150 : 80;
                    const count = isHigh ? 6 : 4;
                    const opacity = isHigh ? 0.3 : 0.55;
                    const mat = new THREE.MeshBasicMaterial({color: isDay ? 0xffffff : 0x444466, transparent:true, opacity});
                    for(let j=0; j<count; j++) {
                        const sz = baseSize + Math.random() * baseSize;
                        const s = new THREE.Mesh(new THREE.SphereGeometry(sz, 7, 5), mat);
                        s.position.set((Math.random()-0.5)*sz*2.5, Math.random()*sz*0.3, (Math.random()-0.5)*sz*2.5);
                        s.scale.y = 0.35;
                        cloud.add(s);
                    }
                    const alt = isHigh ? 4000 + Math.random()*2000 : 1500 + Math.random()*1500;
                    cloud.position.set((Math.random()-0.5)*60000, alt, (Math.random()-0.5)*60000);
                    this.scene.add(cloud);
                }

                // City buildings on islands
                for(let c=0; c<4; c++) {
                    const cx = (Math.random()-0.5)*30000;
                    const cz = (Math.random()-0.5)*30000;
                    // Island terrain under city
                    const iRadius = 600 + Math.random()*400;
                    const island = new THREE.Mesh(
                        new THREE.CircleGeometry(iRadius, 24),
                        new THREE.MeshStandardMaterial({color: 0x2d5a1e, roughness:0.9})
                    );
                    island.rotation.x = -Math.PI/2; island.position.set(cx, 0.5, cz);
                    this.scene.add(island);
                    // Beach ring
                    const beach = new THREE.Mesh(
                        new THREE.RingGeometry(iRadius, iRadius + 80, 24),
                        new THREE.MeshStandardMaterial({color: 0xc2b280, roughness:0.95})
                    );
                    beach.rotation.x = -Math.PI/2; beach.position.set(cx, 0.3, cz);
                    this.scene.add(beach);
                    // Buildings
                    for(let i=0; i<20; i++) {
                        const h = 30 + Math.random()*200;
                        const w = 20 + Math.random()*40;
                        const useCyl = Math.random() > 0.75;
                        const geo = useCyl ? new THREE.CylinderGeometry(w/2, w/2, h, 8) : new THREE.BoxGeometry(w, h, w);
                        const bld = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
                            color: 0x334455 + Math.floor(Math.random()*0x222222),
                            emissive: isDay ? 0x000000 : 0x332200,
                            emissiveIntensity: isDay ? 0 : 0.25
                        }));
                        const bx = cx + (Math.random()-0.5)*600, bz = cz + (Math.random()-0.5)*600;
                        bld.position.set(bx, h/2, bz);
                        this.scene.add(bld);
                        this.entities.buildings.push({ x: bx, z: bz, w: w + 10, h });
                    }
                }

                // Birds
                this.entities.birds = [];
                for(let i=0; i<8; i++) {
                    const bird = new THREE.Group();
                    const birdMat = new THREE.MeshBasicMaterial({color:0x222222, side: THREE.DoubleSide});
                    const wing1 = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), birdMat);
                    wing1.rotation.z = 0.3; wing1.position.x = -2;
                    const wing2 = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), birdMat);
                    wing2.rotation.z = -0.3; wing2.position.x = 2;
                    bird.add(wing1, wing2);
                    bird.position.set((Math.random()-0.5)*20000, 300 + Math.random()*800, (Math.random()-0.5)*20000);
                    this.scene.add(bird);
                    this.entities.birds.push({ mesh: bird, speed: 0.8 + Math.random()*0.5 });
                }

                this.runway = new THREE.Group();
                const deck = new THREE.Mesh(new THREE.BoxGeometry(300, 15, 2500), new THREE.MeshStandardMaterial({color:0x222222}));
                const strip = new THREE.Mesh(new THREE.PlaneGeometry(15, 2500), new THREE.MeshBasicMaterial({color:0xbbbb00}));
                strip.rotation.x = -Math.PI/2; strip.position.y = 7.6;
                this.runway.add(deck, strip);
                this.scene.add(this.runway);
            }

            createLandmarks() {
                const eiffel = new THREE.Group();
                eiffel.add(new THREE.Mesh(new THREE.BoxGeometry(100, 20, 100), new THREE.MeshStandardMaterial({color:0x555555})));
                const b2 = new THREE.Mesh(new THREE.ConeGeometry(40, 400, 4), new THREE.MeshStandardMaterial({color:0x666666}));
                b2.position.y = 210; eiffel.add(b2);
                eiffel.position.set(5000, 0, -5000);
                this.scene.add(eiffel);
                this.entities.landmarks.push({mesh: eiffel, name: 'EIFFEL'});
                this.entities.buildings.push({ x: 5000, z: -5000, w: 100, h: 420 });

                const sol = new THREE.Group();
                sol.add(new THREE.Mesh(new THREE.BoxGeometry(80, 80, 80), new THREE.MeshStandardMaterial({color:0x888888})));
                const body = new THREE.Mesh(new THREE.CylinderGeometry(20, 30, 150, 8), new THREE.MeshStandardMaterial({color:0x66aa99}));
                body.position.y = 115; sol.add(body);
                sol.position.set(-10000, 0, 5000);
                this.scene.add(sol);
                this.entities.landmarks.push({mesh: sol, name: 'LIBERTY'});
                this.entities.buildings.push({ x: -10000, z: 5000, w: 80, h: 230 });
            }

            createShip(type) {
                const group = new THREE.Group();
                if(type === 0) {
                    // Warship (large, gray)
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(70, 30, 250), new THREE.MeshStandardMaterial({color:0x556666})));
                    const tower = new THREE.Mesh(new THREE.BoxGeometry(40, 50, 60), new THREE.MeshStandardMaterial({color:0x667777}));
                    tower.position.set(0, 38, -40); group.add(tower);
                    const mast = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 30, 4), new THREE.MeshStandardMaterial({color:0x888888}));
                    mast.position.set(0, 68, -40); group.add(mast);
                } else if(type === 1) {
                    // Cargo ship (medium, colorful containers)
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(50, 20, 180), new THREE.MeshStandardMaterial({color:0x884422})));
                    const colors = [0xcc3333, 0x3333cc, 0x33cc33, 0xcccc33];
                    for(let i=0; i<3; i++) {
                        const c = new THREE.Mesh(new THREE.BoxGeometry(40, 15, 30), new THREE.MeshStandardMaterial({color: colors[i]}));
                        c.position.set(0, 17, -50 + i*40); group.add(c);
                    }
                    const cabin = new THREE.Mesh(new THREE.BoxGeometry(30, 25, 25), new THREE.MeshStandardMaterial({color:0xdddddd}));
                    cabin.position.set(0, 22, 70); group.add(cabin);
                } else {
                    // Small boat
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(12, 6, 35), new THREE.MeshStandardMaterial({color:0xdddddd})));
                    const cabin = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 8), new THREE.MeshStandardMaterial({color:0x4488aa}));
                    cabin.position.set(0, 5, -5); group.add(cabin);
                }
                return group;
            }

            createAirliner() {
                const group = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color:0xffffff, emissive: 0x111111});
                const body = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 150, 12), mat);
                body.rotation.x = Math.PI/2;
                const wings = new THREE.Mesh(new THREE.BoxGeometry(140, 1.5, 40), mat);
                wings.position.z = 10; group.add(body, wings);
                return group;
            }

            createPlayer() {
                this.player = new THREE.Group();
                const hull = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, metalness: 0.85, roughness: 0.15 });
                const dark = new THREE.MeshStandardMaterial({ color: 0x333340, metalness: 0.9, roughness: 0.2 });
                const glow = new THREE.MeshStandardMaterial({ color: 0x00f2ff, emissive: 0x00f2ff, emissiveIntensity: 0.8 });
                const canopyMat = new THREE.MeshStandardMaterial({ color: 0x00ccff, transparent: true, opacity: 0.6, metalness: 0.3 });
                const engineGlow = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.7 });

                if(this.state.unit === 'JET') {
                    // Nose cone
                    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.5, 3, 8), hull);
                    nose.rotation.x = -Math.PI/2; nose.position.z = -4.5;
                    // Main fuselage
                    const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.9, 6, 10), hull);
                    fuse.rotation.x = Math.PI/2; fuse.position.z = -0.5;
                    // Cockpit canopy
                    const canopy = new THREE.Mesh(new THREE.SphereGeometry(0.55, 8, 6, 0, Math.PI*2, 0, Math.PI/2), canopyMat);
                    canopy.position.set(0, 0.55, -2.8);
                    // Delta wings
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0, 0); wingShape.lineTo(5.5, -2); wingShape.lineTo(4.5, -2.5); wingShape.lineTo(0, -0.8);
                    const wingGeo = new THREE.ExtrudeGeometry(wingShape, {depth: 0.08, bevelEnabled: false});
                    const wingL = new THREE.Mesh(wingGeo, hull); wingL.position.set(0, -0.1, 0); wingL.rotation.x = Math.PI/2;
                    const wingR = new THREE.Mesh(wingGeo, hull); wingR.position.set(0, -0.1, 0); wingR.rotation.x = Math.PI/2; wingR.scale.x = -1;
                    // Wing tip accents
                    const tipL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.06, 0.8), glow); tipL.position.set(5.2, 0, 1.5);
                    const tipR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.06, 0.8), glow); tipR.position.set(-5.2, 0, 1.5);
                    // Vertical tail fin
                    const tailFin = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.2, 1.8), dark);
                    tailFin.position.set(0, 1.1, 2);
                    // Horizontal stabilizers
                    const stabL = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.06, 1.2), hull); stabL.position.set(1.3, 0, 2.2);
                    const stabR = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.06, 1.2), hull); stabR.position.set(-1.3, 0, 2.2);
                    // Engine nacelles
                    const engL = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 2.5, 8), dark);
                    engL.rotation.x = Math.PI/2; engL.position.set(1.2, -0.2, 1);
                    const engR = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 2.5, 8), dark);
                    engR.rotation.x = Math.PI/2; engR.position.set(-1.2, -0.2, 1);
                    // Afterburner glow
                    this.exhaustL = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2, 6), engineGlow);
                    this.exhaustL.rotation.x = -Math.PI/2; this.exhaustL.position.set(1.2, -0.2, 3.2);
                    this.exhaustR = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2, 6), engineGlow);
                    this.exhaustR.rotation.x = -Math.PI/2; this.exhaustR.position.set(-1.2, -0.2, 3.2);
                    // Fuselage accent stripe
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 5), glow);
                    stripe.position.set(0, 0.75, -0.5);

                    this.player.add(nose, fuse, canopy, wingL, wingR, tipL, tipR, tailFin, stabL, stabR, engL, engR, this.exhaustL, this.exhaustR, stripe);
                } else {
                    // UFO - sci-fi saucer
                    const saucer = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 0.8, 24), hull);
                    const rim = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.15, 6, 24), glow);
                    rim.rotation.x = Math.PI/2;
                    const dome = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 12, 0, Math.PI*2, 0, Math.PI/2), canopyMat);
                    dome.position.y = 0.4;
                    const bottom = new THREE.Mesh(new THREE.ConeGeometry(1.8, 1, 12), dark);
                    bottom.position.y = -0.8; bottom.rotation.x = Math.PI;
                    this.exhaustL = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.3, 12), engineGlow);
                    this.exhaustL.position.y = -1.3;
                    this.exhaustR = this.exhaustL; // share reference for UFO
                    this.player.add(saucer, rim, dome, bottom, this.exhaustL);
                }
                this.scene.add(this.player);
                this.player.position.set(0, 15, 1000);
                this.speed = 0;
            }

            spawnUnit(isAlly) {
                const unit = new THREE.Group();
                const baseColor = isAlly ? 0x00aa44 : 0x660000;
                const accentColor = isAlly ? 0x00ff88 : 0xff3300;
                const mat = new THREE.MeshStandardMaterial({ color: baseColor, metalness: 0.7, roughness: 0.3 });
                const accentMat = new THREE.MeshStandardMaterial({ color: accentColor, emissive: accentColor, emissiveIntensity: 0.4 });
                // Fuselage
                const body = new THREE.Mesh(new THREE.ConeGeometry(0.5, 5, 8), mat);
                body.rotation.x = -Math.PI/2;
                // Wings
                const wings = new THREE.Mesh(new THREE.BoxGeometry(7, 0.08, 2), mat);
                wings.position.z = 0.5;
                // Tail
                const tail = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.5, 1.2), mat);
                tail.position.set(0, 0.75, 2);
                // Engine glow
                const eng = new THREE.Mesh(new THREE.ConeGeometry(0.25, 1.2, 6), new THREE.MeshBasicMaterial({color: accentColor, transparent:true, opacity:0.6}));
                eng.rotation.x = -Math.PI/2; eng.position.z = 3;
                // Wing tips
                const tL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.04, 0.6), accentMat); tL.position.set(3.3, 0, 0.8);
                const tR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.04, 0.6), accentMat); tR.position.set(-3.3, 0, 0.8);
                unit.add(body, wings, tail, eng, tL, tR);

                const x = (Math.random()-0.5)*15000; const z = (Math.random()-0.5)*15000;
                unit.position.set(x, 500+Math.random()*1500, z);
                this.scene.add(unit);
                // AI behavior type: 0=chaser, 1=flanker, 2=diver
                const aiType = Math.floor(Math.random()*3);
                const enHp = isAlly ? 3 : Math.ceil(this.state.difficulty / 2);
                const data = { mesh: unit, isAlly, hp: enHp, aiType, phase: 0, phaseTimer: 0,
                    offset: new THREE.Vector3((Math.random()-0.5)*120, (Math.random()-0.5)*60, 60 + Math.random()*60),
                    baseSpeed: this.diff.enSpd };
                if(isAlly) this.entities.allies.push(data); else this.entities.enemies.push(data);
            }

            setupUI() {
                const bnd = (id, key) => document.getElementById(id).querySelectorAll('.opt-btn').forEach(b => b.onclick = () => {
                    document.getElementById(id).querySelector('.active').classList.remove('active');
                    b.classList.add('active'); this.state[key] = b.dataset.val;
                });
                bnd('unit-select', 'unit'); bnd('diff-select', 'difficulty');

                // Level descriptions
                const levelDescs = {
                    1: 'Lv1: 5kills | Easy | strong auto-aim | HP 15',
                    2: 'Lv2: 10kills | Normal | good aim | HP 12',
                    3: 'Lv3: 20kills | Hard | medium aim | HP 8',
                    4: 'Lv4: 35kills | Expert | weak aim | HP 5',
                    5: 'Lv5: 50kills | ACE | manual aim | HP 3'
                };
                const descEl = document.getElementById('level-desc');
                document.getElementById('diff-select').querySelectorAll('.opt-btn').forEach(b => {
                    b.addEventListener('click', () => { descEl.textContent = levelDescs[b.dataset.val]; this.showRanking(parseInt(b.dataset.val)); });
                });
                this.showRanking(1);

                document.getElementById('start-btn').onclick = () => this.start();

                // Spring-back Lever: up=accelerate, down=decelerate, release=hold speed
                this.input.thrust = 0.5; // start at mid
                this.leverActive = false;
                const leverZone = document.getElementById('speed-lever-zone');
                const leverTrack = document.getElementById('lever-track');
                const leverHandle = document.getElementById('lever-handle');
                const handleLever = (e) => {
                    e.preventDefault();
                    const touch = e.touches ? e.touches[0] : e;
                    const rect = leverTrack.getBoundingClientRect();
                    const y = Math.max(0, Math.min(1, (touch.clientY - rect.top) / rect.height));
                    // y=0 top (accelerate), y=1 bottom (decelerate), 0.5=center
                    leverHandle.style.top = (y * 100) + '%';
                    this.leverInput = 0.5 - y; // +0.5=full accel, -0.5=full decel
                    this.leverActive = true;
                };
                leverZone.addEventListener('touchstart', handleLever, {passive: false});
                leverZone.addEventListener('touchmove', handleLever, {passive: false});
                leverZone.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    leverHandle.style.top = '50%';
                    this.leverInput = 0;
                    this.leverActive = false;
                }, {passive: false});

                // Joystick - dynamic mode with always-visible CSS guide
                const jZone = document.getElementById('joystick-zone');
                const radarLeft = window.innerWidth / 2 - 65;
                jZone.style.left = (radarLeft - 140) + 'px';
                this.joystickActive = false;
                nipplejs.create({
                    zone: jZone,
                    mode: 'dynamic',
                    color: 'cyan',
                    size: 86
                }).on('move', (e, d) => {
                    this.input.joystick.x = d.vector.x;
                    this.input.joystick.y = d.vector.y;
                    this.joystickActive = true;
                }).on('end', () => { this.input.joystick = {x:0, y:0}; this.joystickActive = false; });

                document.getElementById('fire-btn').ontouchstart = (e) => { e.preventDefault(); this.input.firing = true; };
                document.getElementById('fire-btn').ontouchend = () => this.input.firing = false;

                // Auto-fire toggle
                this.autoFire = false;
                const afBtn = document.getElementById('auto-fire-btn');
                afBtn.ontouchstart = (e) => {
                    e.preventDefault();
                    this.autoFire = !this.autoFire;
                    afBtn.classList.toggle('active', this.autoFire);
                    afBtn.textContent = this.autoFire ? 'AUTO ON' : 'AUTO';
                };

                // Pause toggle (P key)
                window.addEventListener('keydown', (e) => {
                    if(e.key === 'p' || e.key === 'P') {
                        if(!this.state.active) return;
                        this.state.paused = !this.state.paused;
                        document.getElementById('msg-box').innerText = this.state.paused ? "PAUSED" : "";
                    }
                });
            }

            start() {
                this.state.difficulty = parseInt(this.state.difficulty);
                this.diff = DIFF[this.state.difficulty];
                this.state.targetKills = this.diff.kills;
                this.initAudio(); this.initWorld(); this.createPlayer();
                this.state.active = true; this.state.takeoff = true;
                this.playerHP = this.diff.hp;
                this.maxHP = this.playerHP;
                this.combo = { count: 0, timer: 0, display: 0 };
                this.powerupState = { rapid: 0, shield: 0 };
                this.powerupSpawnTimer = 15;
                this.flybyCooldown = 0;
                this.slowmo = null;
                this.input.thrust = 1.0; // auto full thrust for takeoff
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
                document.getElementById('msg-box').innerText = "AUTO TAKEOFF...";
                for(let i=0; i<this.state.targetKills; i++) this.spawnUnit(false);
                const allyCount = Math.max(2, Math.floor(this.state.targetKills / 5));
                for(let i=0; i<allyCount; i++) this.spawnUnit(true);
                this.timerInterval = setInterval(() => {
                    if(this.state.active && !this.state.paused) {
                        this.state.timeLeft--;
                        if(this.state.timeLeft <= 0) this.gameOver(false);
                    }
                }, 1000);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                if (!this.state.active || this.state.paused) {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }
                let delta = Math.min(this.clock.getDelta(), 0.1);
                const realDelta = delta;
                if(this.slowmo) {
                    delta *= 0.15;
                    this.slowmo.timer -= realDelta;
                    this.slowmo.angle += realDelta * 1.2;
                    if(this.slowmo.timer <= 0) {
                        this.slowmo = null;
                        this.gameOver(true);
                        return;
                    }
                }

                // Lever: update thrust (clamped 0~1)
                if(this.leverInput) {
                    this.input.thrust = Math.max(0, Math.min(1, this.input.thrust + this.leverInput * delta * 1.5));
                }
                if(this.audio.engine) {
                    if(this.input.thrust > 0.05 && !this.audio.engine.isPlaying) this.audio.engine.play();
                    if(this.audio.engine.isPlaying) this.audio.engine.setPlaybackRate(0.6 + this.input.thrust);
                }

                if(this.state.takeoff) {
                    // Auto takeoff: forced full thrust, 2x acceleration (half time)
                    this.input.thrust = 1.0;
                    this.speed = THREE.MathUtils.lerp(this.speed, 4.5, 0.06);
                    this.player.translateZ(-this.speed);
                    if(this.speed > 2.0) {
                        this.player.rotateX(0.8 * delta);
                        if(this.player.position.y > 150) {
                            this.state.takeoff = false;
                            this.input.thrust = 0.5; // restore to mid after takeoff
                            document.getElementById('msg-box').innerText = "";
                        }
                    }
                } else {
                    const pitch = this.input.joystick.y;
                    const roll = -this.input.joystick.x;

                    if(this.joystickActive && (Math.abs(pitch) > 0.05 || Math.abs(roll) > 0.05)) {
                        // Manual control
                        this.player.rotateX(pitch * 2.5 * delta);
                        this.player.rotateZ(roll * 3.5 * delta);
                        this.player.rotateY(-roll * 1.5 * delta);
                    } else {
                        // Auto-track nearest enemy when joystick idle
                        let nearest = null, nearDist = Infinity;
                        this.entities.enemies.forEach(en => {
                            const d = en.mesh.position.distanceTo(this.player.position);
                            if(d < nearDist) { nearDist = d; nearest = en; }
                        });
                        if(nearest && nearDist < 15000) {
                            const toEnemy = nearest.mesh.position.clone().sub(this.player.position).normalize();
                            const trackQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), toEnemy);
                            this.player.quaternion.slerp(trackQuat, this.diff.track);
                        } else {
                            const targetQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, this.player.rotation.y, 0));
                            this.player.quaternion.slerp(targetQuat, 0.04);
                        }
                    }
                    this.speed = THREE.MathUtils.lerp(this.speed, this.input.thrust * this.diff.maxSpd, 0.05);
                    this.player.translateZ(-this.speed);
                }

                // Building collision
                if(!this.state.takeoff) {
                    if(!this.buildingHitCooldown) this.buildingHitCooldown = 0;
                    if(this.buildingHitCooldown > 0) this.buildingHitCooldown -= delta;
                    if(this.buildingHitCooldown <= 0) {
                        for(const bld of this.entities.buildings) {
                            const dx = Math.abs(this.player.position.x - bld.x);
                            const dz = Math.abs(this.player.position.z - bld.z);
                            const hw = bld.w / 2 + 5;
                            if(dx < hw && dz < hw && this.player.position.y < bld.h) {
                                this.playerHP -= 2;
                                this.shakeAmount = 5.0;
                                this.buildingHitCooldown = 1.0;
                                if(this.audio.hit) { if(this.audio.hit.isPlaying) this.audio.hit.stop(); this.audio.hit.play(); }
                                const flash = document.getElementById('damage-flash');
                                flash.style.opacity = '1';
                                setTimeout(() => flash.style.opacity = '0', 200);
                                const pushDir = new THREE.Vector3(
                                    this.player.position.x - bld.x, Math.max(50, bld.h - this.player.position.y + 50),
                                    this.player.position.z - bld.z
                                ).normalize().multiplyScalar(hw * 2);
                                this.player.position.add(pushDir);
                                if(this.playerHP <= 0) { this.gameOver(false); return; }
                                break;
                            }
                        }
                    }
                }

                this.entities.allies.forEach(al => {
                    let nearEn = null, nearD = Infinity;
                    this.entities.enemies.forEach(en => {
                        const d = en.mesh.position.distanceTo(al.mesh.position);
                        if(d < nearD) { nearD = d; nearEn = en; }
                    });
                    if(nearEn && nearD < 8000) {
                        const dir = nearEn.mesh.position.clone().sub(al.mesh.position).normalize();
                        const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), dir);
                        al.mesh.quaternion.slerp(tq, 0.03);
                        al.mesh.translateZ(-al.baseSpeed * delta * 60);
                        if(!al.fireTimer) al.fireTimer = 0;
                        al.fireTimer -= delta;
                        if(al.fireTimer <= 0 && nearD < 2000) {
                            al.fireTimer = 1.5;
                            const ab = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 4), new THREE.MeshBasicMaterial({color:0x00ff88}));
                            ab.position.copy(al.mesh.position); this.scene.add(ab);
                            const bdir = nearEn.mesh.position.clone().sub(al.mesh.position).normalize().multiplyScalar(45);
                            this.entities.bullets.push({ mesh: ab, life: 1.5, vel: bdir, isAlly: true });
                        }
                    } else {
                        const targetPos = this.player.position.clone().add(al.offset.clone().applyQuaternion(this.player.quaternion));
                        al.mesh.position.lerp(targetPos, 0.04);
                        al.mesh.quaternion.slerp(this.player.quaternion, 0.04);
                    }
                    if(al.mesh.position.y < 100) al.mesh.position.y = 100;
                });

                // Enemy AI - diverse combat behaviors
                const time = this.clock.elapsedTime;
                this.entities.enemies.forEach(en => {
                    const toPlayer = this.player.position.clone().sub(en.mesh.position);
                    const dist = toPlayer.length();
                    const dirN = toPlayer.clone().normalize();
                    en.phaseTimer = (en.phaseTimer || 0) + delta;
                    const spd = en.baseSpeed * delta * 60;
                    const turnRate = this.diff.enTurn;

                    if(en.aiType === 0) {
                        // CHASER: direct pursuit, break off at close range then loop back
                        if(dist < 400) {
                            // Overshoot and loop back
                            en.mesh.translateZ(-spd * 1.5);
                            en.mesh.rotateX(2.5 * delta);
                        } else {
                            const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), dirN);
                            en.mesh.quaternion.slerp(tq, turnRate);
                            en.mesh.translateZ(-spd);
                        }
                    } else if(en.aiType === 1) {
                        // FLANKER: circle around player, attack from side
                        const perpX = dirN.z; const perpZ = -dirN.x;
                        const orbitDir = new THREE.Vector3(perpX, dirN.y * 0.3, perpZ).normalize();
                        if(dist > 2000) orbitDir.lerp(dirN, 0.6);
                        else if(dist < 600) orbitDir.lerp(dirN, -0.3);
                        const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), orbitDir);
                        en.mesh.quaternion.slerp(tq, turnRate * 1.2);
                        en.mesh.translateZ(-spd * 1.1);
                    } else {
                        // DIVER: climb high then dive-bomb, repeat
                        if(en.phaseTimer < 3) {
                            // Climb phase
                            const climbTarget = this.player.position.clone().add(new THREE.Vector3(0, 800, 0));
                            const climbDir = climbTarget.sub(en.mesh.position).normalize();
                            const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), climbDir);
                            en.mesh.quaternion.slerp(tq, turnRate);
                            en.mesh.translateZ(-spd * 0.8);
                        } else {
                            // Dive attack
                            const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), dirN);
                            en.mesh.quaternion.slerp(tq, turnRate * 1.8);
                            en.mesh.translateZ(-spd * 2.0);
                            if(dist < 300 || en.phaseTimer > 6) en.phaseTimer = 0;
                        }
                    }

                    // Evasive roll for visual flair
                    if(dist < 1500) en.mesh.rotateZ(Math.sin(time * 3 + en.aiType) * 0.8 * delta);

                    // Altitude floor
                    if(en.mesh.position.y < 100) en.mesh.position.y = 100;

                    // Enemy fires at player
                    if(!en.fireTimer) en.fireTimer = Math.random() * 2;
                    en.fireTimer -= delta;
                    if(en.fireTimer <= 0 && dist < 3000) {
                        en.fireTimer = this.diff.enFire;
                        // Muzzle flash
                        const flash = new THREE.Mesh(new THREE.SphereGeometry(1.5, 4, 4), new THREE.MeshBasicMaterial({color:0xff6600, transparent:true, opacity:0.9}));
                        flash.position.copy(en.mesh.position); this.scene.add(flash);
                        this.entities.particles.push({ mesh: flash, vel: new THREE.Vector3(0,0,0), life: 0.1 });
                        // Bullet with lead prediction
                        const eb = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 4), new THREE.MeshBasicMaterial({color:0xff4444}));
                        eb.position.copy(en.mesh.position); this.scene.add(eb);
                        const predict = this.player.position.clone().add(new THREE.Vector3(0,0,-this.speed * this.diff.predict).applyQuaternion(this.player.quaternion));
                        const edir = predict.sub(en.mesh.position).normalize().multiplyScalar(45);
                        this.entities.bullets.push({ mesh: eb, life: 1.5, vel: edir, isEnemy: true });
                    }
                });

                // Enemy flyby sound
                if(this.flybyCooldown > 0) this.flybyCooldown -= delta;
                this.entities.enemies.forEach(en => {
                    const d = en.mesh.position.distanceTo(this.player.position);
                    const prev = en._prevDist || d;
                    en._prevDist = d;
                    if(prev > 500 && d < 200 && this.flybyCooldown <= 0) {
                        if(this.audio.flyby) { if(this.audio.flyby.isPlaying) this.audio.flyby.stop(); this.audio.flyby.play(); }
                        this.flybyCooldown = 1.5;
                    }
                });

                // BGM tension based on nearest enemy distance
                if(this.bgmGain && this.bgmCtx) {
                    let minEnemyDist = Infinity;
                    this.entities.enemies.forEach(en => {
                        const d = en.mesh.position.distanceTo(this.player.position);
                        if(d < minEnemyDist) minEnemyDist = d;
                    });
                    const tension = minEnemyDist < 3000 ? 0.15 : 0.06;
                    this.bgmGain.gain.setTargetAtTime(tension, this.bgmCtx.currentTime, 0.3);
                }

                this.entities.ships.forEach(s => { s.mesh.translateZ(s.speed); if(s.mesh.position.z > 40000) s.mesh.position.z = -40000; });
                if(this.entities.birds) this.entities.birds.forEach(b => { b.mesh.translateZ(-b.speed); if(b.mesh.position.z < -20000) b.mesh.position.z = 20000; });
                this.entities.airliners.forEach(a => { 
                    a.mesh.translateZ(a.speed); if(a.mesh.position.z > 40000) a.mesh.position.z = -40000; 
                    a.trailTimer += delta; if(a.trailTimer > 0.15) { this.createTrail(a.mesh.position.clone().add(new THREE.Vector3(0,0,10))); a.trailTimer = 0; }
                });

                // Find nearest enemy for aiming & reticle
                if(!this.fireTimer) this.fireTimer = 0;
                this.fireTimer -= delta;
                let nearestDist = Infinity, nearestEnemy = null;
                this.entities.enemies.forEach(en => {
                    const d = en.mesh.position.distanceTo(this.player.position);
                    if(d < nearestDist && d < 5000) { nearestDist = d; nearestEnemy = en; }
                });

                // Target reticle HUD
                const reticle = document.getElementById('target-reticle');
                const reticleInfo = reticle.querySelector('.reticle-info');
                let canHit = false;
                if(nearestEnemy && !this.state.takeoff) {
                    // Project enemy position to screen
                    const enemyPos = nearestEnemy.mesh.position.clone();
                    const screenPos = enemyPos.clone().project(this.camera);
                    const sx = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const sy = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    // Check if enemy is in front of camera and on screen
                    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(this.player.quaternion);
                    const toEn = enemyPos.clone().sub(this.player.position).normalize();
                    const dot = fwd.dot(toEn);
                    const onScreen = dot > 0.7 && sx > 0 && sx < window.innerWidth && sy > 0 && sy < window.innerHeight;
                    // Check if aimed well enough to hit (angle < 15 degrees)
                    canHit = dot > 0.96 && nearestDist < 3000;

                    if(canHit && !this.wasLocked) {
                        if(this.audio.lockon) { if(this.audio.lockon.isPlaying) this.audio.lockon.stop(); this.audio.lockon.play(); }
                    }
                    this.wasLocked = canHit;
                    if(onScreen) {
                        reticle.style.display = 'block';
                        reticle.style.left = sx + 'px'; reticle.style.top = sy + 'px';
                        reticle.className = canHit ? 'locked' : '';
                        // Scale reticle bigger when closer
                        const scale = canHit ? 1.3 : 0.9;
                        reticle.querySelector('.reticle-ring').style.width = (60*scale)+'px';
                        reticle.querySelector('.reticle-ring').style.height = (60*scale)+'px';
                        reticleInfo.textContent = canHit ? `LOCK ${Math.floor(nearestDist)}m` : `${Math.floor(nearestDist)}m`;
                    } else {
                        reticle.style.display = 'none';
                    }
                } else {
                    reticle.style.display = 'none';
                }

                // Fire: manual or auto-fire when locked on (dot>0.96 && dist<3000)
                const shouldFire = this.input.firing || (this.autoFire && canHit);
                if(shouldFire && this.fireTimer <= 0) {
                    this.fireTimer = this.powerupState && this.powerupState.rapid > 0 ? 0.07 : 0.15;
                    if(navigator.vibrate) navigator.vibrate(20);
                    if(this.audio.laser) { if(this.audio.laser.isPlaying) this.audio.laser.stop(); this.audio.laser.play(); }
                    this.fireToggle = !this.fireToggle;
                    const wingOffset = new THREE.Vector3(this.fireToggle ? 3.5 : -3.5, -0.1, -2).applyQuaternion(this.player.quaternion);
                    const b = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 5), new THREE.MeshBasicMaterial({color:0x00f2ff}));
                    b.position.copy(this.player.position).add(wingOffset); b.quaternion.copy(this.player.quaternion);
                    this.scene.add(b);
                    const mf = new THREE.Mesh(new THREE.SphereGeometry(0.6, 4, 4), new THREE.MeshBasicMaterial({color:0x88ffff, transparent:true, opacity:0.9}));
                    mf.position.copy(b.position); this.scene.add(mf);
                    this.entities.particles.push({ mesh: mf, vel: new THREE.Vector3(0,0,0), life: 0.08 });
                    // Auto-aim bullet guidance
                    let bulletDir = new THREE.Vector3(0,0,-50).applyQuaternion(this.player.quaternion);
                    const aimStrength = this.diff.aim;
                    if(nearestEnemy) {
                        const toEnemy = nearestEnemy.mesh.position.clone().sub(this.player.position).normalize().multiplyScalar(50);
                        bulletDir.lerp(toEnemy, aimStrength);
                    }
                    this.entities.bullets.push({ mesh: b, life: 1.8, vel: bulletDir });
                }

                for(let i=this.entities.bullets.length-1; i>=0; i--) {
                    const b = this.entities.bullets[i]; b.mesh.position.add(b.vel); b.life -= delta;
                    if(!b.isEnemy) {
                        for(let ei = this.entities.enemies.length - 1; ei >= 0; ei--) {
                            const en = this.entities.enemies[ei];
                            if(b.mesh.position.distanceTo(en.mesh.position) < 60) {
                                en.hp--;
                                b.life = 0;
                                if(en.hp <= 0) {
                                    if(this.audio.explosion) { if(this.audio.explosion.isPlaying) this.audio.explosion.stop(); this.audio.explosion.play(); }
                                    this.createExplosion(en.mesh.position);
                                    this.scene.remove(en.mesh); this.entities.enemies.splice(ei, 1);
                                    if(!b.isAlly) {
                                        this.state.kills++;
                                        if(navigator.vibrate) navigator.vibrate(50);
                                        this.combo.count++;
                                        this.combo.timer = 5.0;
                                        this.showCombo();
                                        if(this.state.kills >= this.state.targetKills) {
                                            this.slowmo = { active: true, timer: 2.5, target: en.mesh.position.clone(), angle: 0 };
                                        }
                                    }
                                } else {
                                    if(this.audio.hit) { if(this.audio.hit.isPlaying) this.audio.hit.stop(); this.audio.hit.play(); }
                                }
                                break;
                            }
                        }
                    }
                    // Enemy bullet hits player
                    if(b.isEnemy && this.player && b.mesh.position.distanceTo(this.player.position) < 30) {
                        b.life = 0;
                        if(this.powerupState && this.powerupState.shield > 0) {
                            // Shield absorbs hit
                        } else {
                            this.createExplosion(this.player.position.clone());
                            if(this.audio.explosion) { if(this.audio.explosion.isPlaying) this.audio.explosion.stop(); this.audio.explosion.play(); }
                            if(this.audio.hit) { if(this.audio.hit.isPlaying) this.audio.hit.stop(); this.audio.hit.play(); }
                            if(navigator.vibrate) navigator.vibrate([100, 50, 100]);
                            this.shakeAmount = 3.0;
                            this.playerHP--;
                            const flash = document.getElementById('damage-flash');
                            flash.style.opacity = '1';
                            setTimeout(() => flash.style.opacity = '0', 150);
                            if(this.playerHP <= 0) this.gameOver(false);
                        }
                    }
                    if(b.life <= 0) { this.scene.remove(b.mesh); this.entities.bullets.splice(i, 1); }
                }

                // Radar Update
                const dots = document.getElementById('radar-dots'); dots.innerHTML = '';
                [...this.entities.enemies, ...this.entities.allies, ...this.entities.landmarks].forEach(ent => {
                    const dx = ent.mesh.position.x - this.player.position.x;
                    const dz = ent.mesh.position.z - this.player.position.z;
                    if(dx*dx + dz*dz < 10000*10000) {
                        const dot = document.createElement('div'); dot.className = 'radar-dot';
                        dot.style.left = (dx / 10000) * 65 + 65 + 'px'; dot.style.top = (dz / 10000) * 65 + 65 + 'px';
                        dot.style.backgroundColor = ent.isAlly ? 'var(--ally)' : (ent.name ? 'white' : 'var(--danger)');
                        dots.appendChild(dot);
                    }
                });

                if(Math.abs(this.player.position.x) > 40000) this.player.position.x *= -0.99;
                if(Math.abs(this.player.position.z) > 40000) this.player.position.z *= -0.99;

                // Ocean wave animation
                if(this.ocean) {
                    const oPos = this.ocean.geometry.attributes.position;
                    const t2 = this.clock.elapsedTime;
                    for(let i = 0; i < oPos.count; i++) {
                        const x = oPos.getX(i), z = oPos.getZ(i);
                        oPos.setY(i, Math.sin(x * 0.0008 + t2 * 0.5) * 15 + Math.cos(z * 0.0006 + t2 * 0.3) * 10 + Math.sin((x+z) * 0.0004 + t2 * 0.7) * 8);
                    }
                    oPos.needsUpdate = true;
                }

                // Afterburner effect - scale with thrust
                if(this.exhaustL) {
                    const s = 0.3 + this.input.thrust * 1.5 + Math.sin(time * 20) * 0.2;
                    this.exhaustL.scale.set(1, s, 1);
                    if(this.exhaustR !== this.exhaustL) this.exhaustR.scale.set(1, s, 1);
                }

                // Player engine trail
                if(!this.state.takeoff && this.speed > 2 && Math.random() < 0.3) {
                    const trailPos = this.player.position.clone().add(new THREE.Vector3(0, -0.2, 3).applyQuaternion(this.player.quaternion));
                    const t = new THREE.Mesh(new THREE.SphereGeometry(0.5, 4, 4), new THREE.MeshBasicMaterial({color:0x4488ff, transparent:true, opacity:0.5}));
                    t.position.copy(trailPos); this.scene.add(t);
                    this.entities.particles.push({ mesh: t, vel: new THREE.Vector3(0,0,0), life: 0.6 });
                }

                // Camera with shake on hit
                if(!this.shakeAmount) this.shakeAmount = 0;
                this.shakeAmount *= 0.9;
                const shakeOff = new THREE.Vector3((Math.random()-0.5)*this.shakeAmount, (Math.random()-0.5)*this.shakeAmount, 0);
                const camOff = new THREE.Vector3(0, 3.8, 13 + this.speed*2.5).applyQuaternion(this.player.quaternion);
                this.camera.position.lerp(this.player.position.clone().add(camOff).add(shakeOff), 0.15);
                this.camera.lookAt(this.player.position.clone().add(new THREE.Vector3(0,0,-25).applyQuaternion(this.player.quaternion)));
                // Slowmo killcam camera override
                if(this.slowmo) {
                    const t = this.slowmo.target;
                    const r = 300;
                    this.camera.position.set(t.x + Math.cos(this.slowmo.angle) * r, t.y + 100, t.z + Math.sin(this.slowmo.angle) * r);
                    this.camera.lookAt(t);
                }

                // Particle update
                for(let i=this.entities.particles.length-1; i>=0; i--) {
                    const p = this.entities.particles[i];
                    p.mesh.position.add(p.vel);
                    p.life -= delta;
                    if(p.isRing) {
                        const s = 1 + (0.5 - p.life) * 12;
                        p.mesh.scale.set(s, s, s);
                    }
                    p.mesh.material.opacity = Math.max(0, p.life / (p.isSmoke ? 2.5 : p.isRing ? 0.5 : 2.0));
                    if(p.life <= 0) { this.scene.remove(p.mesh); this.entities.particles.splice(i, 1); }
                }

                // Combo timer
                if(this.combo && this.combo.timer > 0) {
                    this.combo.timer -= delta;
                    if(this.combo.timer <= 0) this.combo.count = 0;
                }
                if(this.combo && this.combo.display > 0) {
                    this.combo.display -= delta;
                    if(this.combo.display <= 0) document.getElementById('combo-text').style.opacity = '0';
                }

                // Powerup system
                if(this.powerupSpawnTimer !== undefined) {
                    this.powerupSpawnTimer -= delta;
                    if(this.powerupSpawnTimer <= 0) {
                        this.powerupSpawnTimer = 15;
                        this.createPowerup();
                    }
                }
                for(let pi = this.entities.powerups.length - 1; pi >= 0; pi--) {
                    const pu = this.entities.powerups[pi];
                    pu.mesh.rotation.y += delta * 2;
                    pu.life -= delta;
                    if(this.player && pu.mesh.position.distanceTo(this.player.position) < 80) {
                        if(pu.type === 'heal') this.playerHP = Math.min(this.maxHP, this.playerHP + 3);
                        else if(pu.type === 'shield') this.powerupState.shield = 8;
                        else if(pu.type === 'rapid') this.powerupState.rapid = 8;
                        this.scene.remove(pu.mesh); this.entities.powerups.splice(pi, 1);
                        continue;
                    }
                    if(pu.life <= 0) { this.scene.remove(pu.mesh); this.entities.powerups.splice(pi, 1); }
                }
                if(this.powerupState.shield > 0) this.powerupState.shield -= delta;
                if(this.powerupState.rapid > 0) this.powerupState.rapid -= delta;
                const puInd = document.getElementById('powerup-indicator');
                let puHTML = '';
                if(this.powerupState.shield > 0) puHTML += `<div class="pu-active" style="background:rgba(0,150,255,0.3);color:#00aaff;">SHIELD ${Math.ceil(this.powerupState.shield)}s</div>`;
                if(this.powerupState.rapid > 0) puHTML += `<div class="pu-active" style="background:rgba(255,200,0,0.3);color:#ffcc00;">RAPID ${Math.ceil(this.powerupState.rapid)}s</div>`;
                puInd.innerHTML = puHTML;

                if(!this.state.takeoff && this.player.position.y < 5) this.gameOver(false);

                document.getElementById('alt-val').innerText = Math.floor(this.player.position.y);
                document.getElementById('spd-val').innerText = (this.speed * 180).toFixed(0);
                const hpRatio = this.playerHP / this.maxHP;
                const hpFill = document.getElementById('hp-fill');
                hpFill.style.width = (hpRatio * 100) + '%';
                hpFill.style.background = hpRatio > 0.5 ? '#00ff88' : hpRatio > 0.25 ? '#ffaa00' : '#ff4444';
                document.getElementById('damage-vignette').style.opacity = hpRatio < 0.25 ? '1' : hpRatio < 0.5 ? '0.4' : '0';
                document.getElementById('kill-val').innerText = this.state.kills;
                document.getElementById('target-val').innerText = this.state.targetKills;
                const mm = Math.floor(this.state.timeLeft/60); const ss = String(this.state.timeLeft%60).padStart(2,'0');
                document.getElementById('timer-val').innerText = mm+':'+ss;
                this.renderer.render(this.scene, this.camera);
            }

            createExplosion(pos) {
                // Core flash
                const flash = new THREE.Mesh(new THREE.SphereGeometry(12, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1.0 }));
                flash.position.copy(pos); this.scene.add(flash);
                this.entities.particles.push({ mesh: flash, vel: new THREE.Vector3(0,0,0), life: 0.15 });
                // Shockwave ring
                const ring = new THREE.Mesh(new THREE.TorusGeometry(5, 1.5, 6, 16), new THREE.MeshBasicMaterial({ color: 0xffaa44, transparent: true, opacity: 0.8 }));
                ring.position.copy(pos); this.scene.add(ring);
                this.entities.particles.push({ mesh: ring, vel: new THREE.Vector3(0,0,0), life: 0.5, isRing: true });
                // Camera shake from nearby explosions
                const camDist = pos.distanceTo(this.camera.position);
                if(camDist < 500) this.shakeAmount = Math.max(this.shakeAmount || 0, 2.0 * (1 - camDist/500));
                // Fire + smoke + sparks
                for(let i=0; i<40; i++) {
                    const r = Math.random();
                    let color, size, life, speed;
                    if(r < 0.3) { color = 0xff4400; size = 3; life = 0.8; speed = 18; } // fire core
                    else if(r < 0.6) { color = 0xffaa00; size = 2; life = 1.0; speed = 14; } // fire outer
                    else if(r < 0.8) { color = 0x555555; size = 5; life = 2.5; speed = 6; } // smoke
                    else { color = 0xffff44; size = 0.5; life = 0.6; speed = 25; } // sparks
                    const p = new THREE.Mesh(new THREE.SphereGeometry(size, 6, 6), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1.0 }));
                    p.position.copy(pos); this.scene.add(p);
                    const vel = new THREE.Vector3((Math.random()-0.5)*speed, (Math.random()-0.5)*speed + 3, (Math.random()-0.5)*speed);
                    this.entities.particles.push({ mesh: p, vel, life, isSmoke: r >= 0.6 && r < 0.8 });
                }
                // Debris chunks
                for(let i=0; i<5; i++) {
                    const d = new THREE.Mesh(new THREE.BoxGeometry(1+Math.random()*2, 0.5, 1+Math.random()*2), new THREE.MeshStandardMaterial({color:0x333333}));
                    d.position.copy(pos); this.scene.add(d);
                    this.entities.particles.push({ mesh: d, vel: new THREE.Vector3((Math.random()-0.5)*15, Math.random()*10, (Math.random()-0.5)*15), life: 2.0 });
                }
            }

            createTrail(pos) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(3, 4, 4), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 }));
                p.position.copy(pos); this.scene.add(p);
                this.entities.particles.push({ mesh: p, vel: new THREE.Vector3(0,0,0), life: 2.0 });
            }

            createPowerup() {
                const types = ['heal', 'shield', 'rapid'];
                const colors = { heal: 0x00ff88, shield: 0x0088ff, rapid: 0xffcc00 };
                const type = types[Math.floor(Math.random() * types.length)];
                const group = new THREE.Group();
                const core = new THREE.Mesh(new THREE.OctahedronGeometry(8, 0), new THREE.MeshStandardMaterial({ color: colors[type], emissive: colors[type], emissiveIntensity: 0.6 }));
                const ring = new THREE.Mesh(new THREE.TorusGeometry(12, 1, 6, 16), new THREE.MeshBasicMaterial({ color: colors[type], transparent: true, opacity: 0.5 }));
                group.add(core, ring);
                const px = this.player.position.x + (Math.random() - 0.5) * 4000;
                const pz = this.player.position.z + (Math.random() - 0.5) * 4000;
                const py = 300 + Math.random() * 1200;
                group.position.set(px, py, pz);
                this.scene.add(group);
                this.entities.powerups.push({ mesh: group, type, life: 20 });
            }

            showCombo() {
                const ct = document.getElementById('combo-text');
                const c = this.combo.count;
                if(c < 2) { ct.textContent = 'KILL!'; ct.style.color = '#ffffff'; }
                else if(c === 2) { ct.textContent = 'DOUBLE KILL!'; ct.style.color = '#ffdd00'; }
                else if(c === 3) { ct.textContent = 'TRIPLE KILL!'; ct.style.color = '#ff8800'; }
                else if(c < 5) { ct.textContent = `${c}x COMBO!`; ct.style.color = '#ff4400'; }
                else if(c < 10) { ct.textContent = 'RAMPAGE!'; ct.style.color = '#ff0044'; }
                else { ct.textContent = 'UNSTOPPABLE!'; ct.style.color = '#ffcc00'; }
                ct.style.opacity = '1';
                ct.style.transform = 'translate(-50%,-50%) scale(1.2)';
                setTimeout(() => { ct.style.transform = 'translate(-50%,-50%) scale(1)'; }, 100);
                this.combo.display = 1.2;
            }

            saveRanking(level, score) {
                const key = 'skyline_scores_lv' + level;
                let scores = JSON.parse(localStorage.getItem(key) || '[]');
                scores.push({ score, date: new Date().toLocaleDateString() });
                scores.sort((a, b) => b.score - a.score);
                scores = scores.slice(0, 10);
                localStorage.setItem(key, JSON.stringify(scores));
            }

            showRanking(level) {
                const key = 'skyline_scores_lv' + level;
                const scores = JSON.parse(localStorage.getItem(key) || '[]');
                const container = document.getElementById('top-scores');
                const list = document.getElementById('scores-list');
                if(scores.length === 0) { container.style.display = 'none'; return; }
                container.style.display = 'block';
                list.innerHTML = scores.map((s, i) =>
                    `<div style="display:flex;justify-content:space-between;"><span style="color:${i < 3 ? '#ffdd00' : 'inherit'};">#${i+1}</span><span>${s.score.toLocaleString()}</span><span style="opacity:0.5;">${s.date}</span></div>`
                ).join('');
            }

            gameOver(success) {
                this.state.active = false; clearInterval(this.timerInterval);
                document.getElementById('target-reticle').style.display = 'none';
                const baseScore = this.state.kills * 100 * this.state.difficulty;
                const score = baseScore + (success ? this.state.timeLeft * 50 : 0);
                this.saveRanking(this.state.difficulty, score);
                const ratio = this.state.kills / this.state.targetKills;
                let recLevel = this.state.difficulty;
                if(success && ratio >= 1 && this.state.timeLeft > 20) recLevel = Math.min(5, recLevel + 1);
                else if(!success && ratio < 0.3) recLevel = Math.max(1, recLevel - 1);

                const btns = document.getElementById('over-buttons');

                if(success) {
                    // Mission complete: return to base, offer next sortie
                    document.getElementById('over-title').innerText = "RETURNING TO BASE";
                    let stats = `MISSION COMPLETE!\nACE LEVEL ${this.state.difficulty} | KILLS: ${this.state.kills} / ${this.state.targetKills}\nSCORE: ${score}`;
                    if(recLevel !== this.state.difficulty) stats += `\nRECOMMENDED NEXT: Level ${recLevel}`;
                    document.getElementById('over-stats').innerText = stats;
                    const nextLevel = Math.min(5, this.state.difficulty + 1);
                    btns.innerHTML = `
                        <button class="start-btn" style="margin-top:10px;background:var(--accent);color:#000;" onclick="window._game.sortie(${nextLevel})">SORTIE LV${nextLevel}</button>
                        <button class="start-btn" style="margin-top:8px;background:rgba(255,255,255,0.1);color:white;border:1px solid rgba(255,255,255,0.2);" onclick="window._game.sortie(${this.state.difficulty})">REPLAY LV${this.state.difficulty}</button>
                        <button class="start-btn" style="margin-top:8px;" onclick="location.reload()">MAIN MENU</button>`;
                } else {
                    document.getElementById('over-title').innerText = "MISSION FAILED";
                    let stats = `ACE LEVEL ${this.state.difficulty} | KILLS: ${this.state.kills} / ${this.state.targetKills}\nSCORE: ${score}`;
                    if(recLevel !== this.state.difficulty) stats += `\nRECOMMENDED: Level ${recLevel}`;
                    document.getElementById('over-stats').innerText = stats;
                    btns.innerHTML = `
                        <button class="start-btn" style="margin-top:10px;" onclick="window._game.sortie(${this.state.difficulty})">RETRY LV${this.state.difficulty}</button>
                        <button class="start-btn" style="margin-top:8px;background:rgba(255,255,255,0.1);color:white;border:1px solid rgba(255,255,255,0.2);" onclick="location.reload()">MAIN MENU</button>`;
                }
                document.getElementById('over-screen').style.display = 'flex';
                if(this.audio.engine) this.audio.engine.stop();
                if(this.bgmGain) this.bgmGain.gain.setTargetAtTime(0, this.bgmCtx.currentTime, 0.5);
            }

            sortie(level) {
                // Clean up current scene entities
                [...this.entities.enemies, ...this.entities.allies].forEach(e => this.scene.remove(e.mesh));
                this.entities.bullets.forEach(b => this.scene.remove(b.mesh));
                this.entities.particles.forEach(p => this.scene.remove(p.mesh));
                this.entities.enemies = []; this.entities.allies = [];
                this.entities.bullets = []; this.entities.particles = [];
                // Reset state for new sortie
                this.state.difficulty = level;
                this.diff = DIFF[level];
                this.state.targetKills = this.diff.kills;
                this.state.kills = 0; this.state.timeLeft = 300;
                this.state.active = true; this.state.takeoff = true;
                this.playerHP = this.diff.hp;
                this.maxHP = this.playerHP;
                this.combo = { count: 0, timer: 0, display: 0 };
                this.powerupState = { rapid: 0, shield: 0 };
                this.powerupSpawnTimer = 15;
                this.slowmo = null;
                this.entities.powerups.forEach(p => this.scene.remove(p.mesh));
                this.entities.powerups = [];
                this.input.thrust = 1.0; this.speed = 0;
                this.player.position.set(0, 15, 1000);
                this.player.quaternion.identity();
                for(let i=0; i<this.state.targetKills; i++) this.spawnUnit(false);
                const allyCount = Math.max(2, Math.floor(this.state.targetKills / 5));
                for(let i=0; i<allyCount; i++) this.spawnUnit(true);
                document.getElementById('over-screen').style.display = 'none';
                document.getElementById('msg-box').innerText = "AUTO TAKEOFF...";
                this.timerInterval = setInterval(() => {
                    if(this.state.active && !this.state.paused) {
                        this.state.timeLeft--;
                        if(this.state.timeLeft <= 0) this.gameOver(false);
                    }
                }, 1000);
            }
        }
        window.onload = () => { window._game = new Game(); };
    </script>
</body>
</html>